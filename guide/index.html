<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-10-02 Mon 16:49 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Linkspace Guide</title>
<meta name="generator" content="Org Mode" />
<link rel="icon" type="image/x-icon" href="../../images/logo.png">
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
<script type="text/javascript" src="./org-utils.js"></script>
<link rel="stylesheet" type="text/css" href="./style.css"/>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">The Linkspace Guide</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org3077060">Introduction</a></li>
<li><a href="#setup">Setup</a>
<ul>
<li><a href="#orgcd0929f">Binary</a></li>
<li><a href="#orga5968d0">Package manager</a></li>
<li><a href="#org3b4a94f">Build from source</a>
<ul>
<li><a href="#orge8ad456">for users</a></li>
<li><a href="#orgfb9101d">for development / debug builds</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#api">API overview</a></li>
<li><a href="#Point">Point</a>
<ul>
<li><a href="#lk_datapoint">lk_datapoint</a></li>
<li><a href="#lk_linkpoint">lk_linkpoint</a></li>
<li><a href="#lk_keypoint">lk_keypoint</a></li>
<li><a href="#org4664cde">Fields</a></li>
<li><a href="#org668f791">Notes</a></li>
<li><a href="#packet_layout">lk_write and lk_read</a></li>
</ul>
</li>
<li><a href="#ABE">ABE</a>
<ul>
<li><a href="#orge2b5cbd">Basic Encoding</a></li>
<li><a href="#org381da7a">lk_eval</a>
<ul>
<li><a href="#org592c454">Sub-expressions</a>
<ul>
<li><a href="#org404e6b9">Functions</a></li>
<li><a href="#org120c247">Macros</a></li>
</ul>
</li>
<li><a href="#scope">Scope &amp; Context</a>
<ul>
<li><a href="#org87cb53c">Argv</a></li>
<li><a href="#pkt-scope">Packet</a></li>
<li><a href="#org71f9d24">Runtime</a></li>
</ul>
</li>
<li><a href="#orgc3c7a86">Usage notes</a></li>
<li><a href="#abe-help">Help</a></li>
</ul>
</li>
<li><a href="#lk_encode">lk_encode</a>
<ul>
<li><a href="#org5717c23">DEFAULT_FMT</a></li>
</ul>
</li>
<li><a href="#lk_tokenize_abe">lk_tokenize_abe</a></li>
<li><a href="#ABELNS">LNS</a></li>
</ul>
</li>
<li><a href="#Query">Query</a>
<ul>
<li><a href="#lk_query">lk_query</a></li>
<li><a href="#lk_query_parse">lk_query_parse</a></li>
<li><a href="#lk_query_push">lk_query_push</a></li>
<li><a href="#lk_query_print">lk_query_print</a></li>
<li><a href="#orgedcb4d4">More on predicates</a>
<ul>
<li><a href="#orgedb0679">Recv</a></li>
</ul>
</li>
<li><a href="#orgff09b95">Options</a></li>
<li><a href="#predicatelist">Known predicates &amp; options</a></li>
<li><a href="#lk_hash_query">lk_hash_query</a></li>
</ul>
</li>
<li><a href="#runtime">Runtime</a>
<ul>
<li><a href="#lk_open">lk_open</a></li>
<li><a href="#lk_save">lk_save</a></li>
<li><a href="#lk_get">lk_get</a></li>
<li><a href="#lk_get_all">lk_get_all</a></li>
<li><a href="#lk_get">lk_get_hash</a></li>
<li><a href="#lk_watch">lk_watch</a></li>
<li><a href="#lk_process">lk_process</a></li>
<li><a href="#lk_process_while">lk_process_while</a></li>
<li><a href="#lk_close_watch">lk_close_watch</a></li>
</ul>
</li>
<li><a href="#Conventions">Conventions</a>
<ul>
<li><a href="#lk_status_set">lk_status_set</a></li>
<li><a href="#lk_status_poll">lk_status_poll</a></li>
<li><a href="#lk_pull">lk_pull</a></li>
<li><a href="#lk_key">lk_key</a></li>
</ul>
</li>
<li><a href="#lns">LNS</a></li>
<li><a href="#orgb40058f">Advanced topics</a>
<ul>
<li><a href="#bigdata">Big data</a></li>
</ul>
</li>
<li><a href="#qa">Q&amp;A</a>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#org939469c">Why Big Endian?</a></li>
<li><a href="#org92dc42c">Every user of my domain app needs X from my server/I want to add advertisements to my domain app.</a></li>
<li><a href="#orgbf6d952">I'm not in control of the user! / Anybody in my group can leak data from it!?</a></li>
<li><a href="#orgabb173b">A domain application can write outside its own domain space.</a></li>
<li><a href="#org0d3ca55">Why don't queries support negative predicates?</a></li>
<li><a href="#org8ec91af">Why not use an SQL backend? / Why create Queries?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
<p class="verse">
This document is kept up to date on a best effort basis.<br>
Sometimes the Rust <a href="../docs/rust/linkspace/index.html">linkspace</a> docs is ahead of this guide.<br>
</p>

<p>
This is a technical document describing the linkspace packet format, and software library to create, query, and process packets.
</p>

<div class="org-src-container">
<pre class="src src-bash">lk --version
</pre>
</div>

<pre class="example" id="orgd431af7">
linkspace-cli linkspace-cli - 0.4.0 - main - a5d257c - 1.74.0-nightly
</pre>

<div id="outline-container-org3077060" class="outline-2">
<h2 id="org3077060">Introduction</h2>
<div class="outline-text-2" id="text-org3077060">
<p>
Linkspace is a open-source library and protocol to build event-driven applications using a distributed log as a source of truth.
The linkspace packet format is designed to be extremely fast to read, write, and interpret.
Depending on your use case, you can limit yourself to just those functions and write your event streams and network from scratch.
The library has various tools to make developing increasingly complex systems much easier. 
</p>

<p>
The library is structured around 4 concepts.
</p>

<ul class="org-ul">
<li><a href="#Point">Point</a> - Plain bytes in any format, optionally with a spacename and links to other points.</li>
<li><a href="#ABE">ABE</a> - Language agnostic (byte) templating for convenience.</li>
<li><a href="#Query">Query</a> - A list of predicates and options for selecting packets.</li>
<li><a href="#runtime">Runtime</a> - A runtime around a multi-reader single-writer database for saving and querying.</li>
</ul>

<p>
With that foundation, common challenges are addressed by a set of <a href="#Conventions">Conventions</a>.
</p>
</div>
</div>

<div id="outline-container-setup" class="outline-2">
<h2 id="setup">Setup</h2>
<div class="outline-text-2" id="text-setup">
<p>
This guide uses Python and (Bash) CLI snippets.
</p>
</div>

<div id="outline-container-orgcd0929f" class="outline-3">
<h3 id="orgcd0929f">Binary</h3>
<div class="outline-text-3" id="text-orgcd0929f">
<p>
The <a href="https://github.com/AntonSol919/linkspace/releases">download</a> contains the CLI and python library and the examples used in this document.
</p>
</div>
</div>

<div id="outline-container-orga5968d0" class="outline-3">
<h3 id="orga5968d0">Package manager</h3>
<div class="outline-text-3" id="text-orga5968d0">
<p>
<code>pip install linkspace</code>
</p>

<p>
<code>cargo +nightly install linkspace-cli --git https://github.com/AntonSol919/linkspace</code>
</p>
</div>
</div>

<div id="outline-container-org3b4a94f" class="outline-3">
<h3 id="org3b4a94f">Build from source</h3>
<div class="outline-text-3" id="text-org3b4a94f">
<p>
<code>git clone https://github.com/AntonSol919/linkspace</code>
</p>
</div>

<div id="outline-container-orge8ad456" class="outline-4">
<h4 id="orge8ad456">for users</h4>
<div class="outline-text-4" id="text-orge8ad456">
<p>
<code>make install-lk install-python</code>
</p>
</div>
</div>

<div id="outline-container-orgfb9101d" class="outline-4">
<h4 id="orgfb9101d">for development / debug builds</h4>
<div class="outline-text-4" id="text-orgfb9101d">
<p>
<code>source ./activate</code> builds and sets PATH and PYTHONPATH env variables.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-api" class="outline-2">
<h2 id="api">API overview</h2>
<div class="outline-text-2" id="text-api">
<p>
The linkspace API is the Packet type and a small set of functions.
It is available as a Rust crate <code>linkspace</code> and binding for other languages follow the same API.
</p>

<p>
It consists of the following:
</p>

<ul class="org-ul">
<li><a href="#Point">Point</a> 
<ul class="org-ul">
<li><a href="#lk_datapoint">lk_datapoint</a></li>
<li><a href="#lk_linkpoint">lk_linkpoint</a></li>
<li><a href="#lk_keypoint">lk_keypoint</a></li>
<li><a href="#packet_layout">lk_write and lk_read</a></li>
</ul></li>

<li><a href="#ABE">ABE</a> - (Byte) templating for convenience
<ul class="org-ul">
<li><a href="#org381da7a">lk_eval</a></li>
<li><a href="#lk_encode">lk_encode</a></li>
</ul></li>

<li><a href="#Query">Query</a> - Addressing and filtering of packets with predicates and options
<ul class="org-ul">
<li><a href="#lk_query">lk_query</a></li>
<li><a href="#lk_query_parse">lk_query_parse</a></li>
<li><a href="#lk_query_push">lk_query_push</a></li>
<li><a href="#lk_query_print">lk_query_print</a></li>
</ul></li>

<li><a href="#runtime">Runtime</a> - A database to save packets and user-driven event loop to query for old and new packets.
<ul class="org-ul">
<li><a href="#lk_open">lk_open</a></li>
<li><a href="#lk_save">lk_save</a></li>
<li><a href="#lk_get">lk_get</a></li>
<li><a href="#lk_get_all">lk_get_all</a></li>
<li><a href="#lk_watch">lk_watch</a></li>
<li><a href="#lk_process">lk_process</a></li>
<li><a href="#lk_process_while">lk_process_while</a></li>
</ul></li>

<li><a href="#Conventions">Conventions</a> - Functions following a convention build on top of the core functions.
<ul class="org-ul">
<li><a href="#lk_status_set">lk_status_set</a></li>
<li><a href="#lk_status_poll">lk_status_poll</a></li>
<li><a href="#lk_pull">lk_pull</a></li>
<li><a href="#lk_key">lk_key</a></li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-Point" class="outline-2">
<h2 id="Point">Point</h2>
<div class="outline-text-2" id="text-Point">
<p class="verse">
<a href="../docs/rust/linkspace/point/index.html">Rust docs</a><br>
</p>

<p>
Points are the basic units in linkspace.
They carry data, link to other points, and might contain information about the who, what, when, and how.
There are 3 kinds of points. datapoints, linkpoints, and keypoints.
A point has a maximum size of 2<sup>16</sup>-512 bytes.
</p>

<p>
The library exposes fields as properties.
</p>

<p>
The functions automatically generate the hash and prepend a netheader when you build a point.
The result is a packet. For simplicity sake, all functions in the library deal only with packets.
</p>
</div>

<div id="outline-container-lk_datapoint" class="outline-3">
<h3 id="lk_datapoint">lk_datapoint</h3>
<div class="outline-text-3" id="text-lk_datapoint">
<div class="ctabs" id="org2e2c10c">
<div class="sh" id="org58c784e">
<p>

</p>

<div class="org-src-container">
<pre class="src src-bash">echo "Hello, Sol!" | lk data | lk pktf "[hash:str]\n[data]"
</pre>
</div>

<pre class="example" id="orgf46e3d2">
Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk
Hello, Sol!
</pre>

</div>

<div class="py" id="orgf6b5642">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">from linkspace import *
datap = lk_datapoint(b"Hello, Sol!\n")
print(f'Packed data {datap.data.decode()} into a packet with hash {b64(datap.hash)}')
print(lk_eval2str("Or use abe, a language agnostic template, like this: [hash:str] = [data]", datap))
</pre>
</div>

</div>

</div>
</div>
</div>

<div id="outline-container-lk_linkpoint" class="outline-3">
<h3 id="lk_linkpoint">lk_linkpoint</h3>
<div class="outline-text-3" id="text-lk_linkpoint">
<p>
A linkpoint can: hold data, hold links to other points, and can be found with by its spacename.
</p>

<p>
It consists of these fields:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Field<sub>size</sub></th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Group<sub>32</sub></td>
<td class="org-left">the intended recipients.</td>
</tr>

<tr>
<td class="org-left">Domain<sub>16</sub></td>
<td class="org-left">the intended application.</td>
</tr>

<tr>
<td class="org-left">Spacename<sub>var&lt;240</sub></td>
<td class="org-left">Sequence of bytes. e.g. '/dir1/dir2/thing'</td>
</tr>

<tr>
<td class="org-left">Stamp<sub>8</sub></td>
<td class="org-left">Big endian UNIX timestamp in microseconds.</td>
</tr>

<tr>
<td class="org-left">Links<sub>48*n</sub></td>
<td class="org-left">A variable length list of (Tag<sub>16</sub>, Pointer<sub>32</sub>)</td>
</tr>

<tr>
<td class="org-left">-Link[0]<sub>48</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">-Link[1]<sub>48</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">-Link[2]<sub>48</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">-Link[&#x2026;]<sub>48</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Data<sub>var&lt;2<sup>16</sup></sub></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Each (Domain,Group) is a 'tree', and each (Domain,Group,Spacename) is a points 'location'.
</p>

<p>
All values, including the Spacename, contain arbitrary bytes.
</p>

<p>
An entire point can be 2<sup>16</sup>-512 bytes in size. The header is always 4 bytes.
A data point can hold a maximum of 2<sup>16</sup>-512-4 bytes.
This space is shared between the links and data so beware that too much data and links won't fit into a single packet
To overcome this, create multiple points and link them in a new linkpoint.
These limits ensure there is only a single level of fragmentation to deal with.
</p>

<p class="verse">
Point hashes, GroupID's, and public keys are 32 bytes.<br>
They are usually encoded in URL-safe no-padding base64, e.g. <code>RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF</code>.<br>
Such a string makes things unreadable.<br>
The <code>[...]</code> syntax (<a href="#ABE">ABE</a>) allows you to name and manipulate bytes.<br>
This following example shows that <code>[#:pub]</code> resolves to the bytes <code>RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF</code> in both the Group and the second link<br>
Furthermore, If no group was provided it defaults to <code>[#:pub]</code><br>
</p>

<p>
Datapoints do not have a 'create' field, so they get the same hash given the same data.
If we had forced a specific 'create' stamp for both the python and bash example it would have produced the same hash for both.
By default 'create' is set to the current time ( microseconds since epoch ) and thus the hashes are different.
</p>

<div class="ctabs" id="orgd4acefc">
<div class="sh" id="org61ad0bf">
<p>

</p>

<p>
The command <code>lk link</code> builds one or more linkpoint packets and output's it to stdout by default.
Whenever a cli commands deal with (domain, group, spacename) tuples, they are set by the first argument: <code>DOMAIN:GROUP:SPACENAME</code>.
Here two links are added with the tags <code>first_tag_1</code> and <code>another_tag</code>.
</p>

<div class="org-src-container">
<pre class="src src-bash">lk link "a_domain:[#:pub]:/dir1/dir2/thing" -- \
          first_tag_1:Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk \
          another_tag:[#:pub] \
| lk pktf

</pre>
</div>

<pre class="example" id="orgd57bbb5">
type	LinkPoint
hash	9zau_Ao6F7-9ii9Rpcs6mQlDE770aqwKEGgIAV8ApW8
group	[#:pub]
domain	a_domain
space	/dir1/dir2/thing
pubkey	[@:none]
create	1696258157338993
links	2
	first_tag_1 Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk
	another_tag Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk

data	0
</pre>

<div class="org-src-container">
<pre class="src src-bash">echo hello | lk link my_domain --data-stdin | lk pktf
</pre>
</div>

<pre class="example" id="org01b8fc9">
type	LinkPoint
hash	-rPmqbmbsuV_ajOUD9QbbeZRzykZwIzU7_bQcrhsu5s
group	[#:pub]
domain	my_domain
space	
pubkey	[@:none]
create	1696258157357869
links	0

data	6
hello
</pre>

</div>


<div class="py" id="orgc50ef4a">
<p>

</p>

<p>
The API deals with arbitrary bytes, not encoded strings.
Some example python code that returns a value of type 'bytes' are:
</p>

<ul class="org-ul">
<li><code>"some string".encode()"</code></li>
<li>the <code>b"byte notation"</code></li>
<li>fields like <code>apkt.group</code>, <code>apkt.hash</code> <code>apkt.domain</code> etc</li>
<li>evaluate an ABE string with <a href="#org381da7a">lk_eval</a>.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python">ptr1 = lk_eval("[b:Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk]")
link1 = Link(tag=b"first tag 1",ptr=ptr1)

ptr2 = lk_eval("[#:pub]")
link2 = Link(b"another tag",ptr2)

assert(link1.ptr == link2.ptr)

datap = lk_datapoint(b"Hello example");
link3 = Link(b"a datapoint",datap.hash)

linkp = lk_linkpoint(
    domain=b"example-domain",
    group=lk_eval("[#:pub]"),
    data=b"Hello, World!",
    links=[link1,link2,link3]
)
str(linkp)
</pre>
</div>

</div>

</div>
</div>
</div>



<div id="outline-container-lk_keypoint" class="outline-3">
<h3 id="lk_keypoint">lk_keypoint</h3>
<div class="outline-text-3" id="text-lk_keypoint">
<p>
A key point is a linkpoint with an additional publickey and signature.
</p>

<p>
There are functions to generate, encrypt, and decrypt a linkspace key.
Leaving you to deal with the saving.
Alternatively there is the <a href="#lk_key">lk_key</a> function that does it all for you.
With the added benefit that you can address your own public key as <code>[@:me:local]</code>.
</p>

<div class="ctabs" id="org0e427dc">
<div class="sh" id="orgc0457b4">
<div class="org-src-container">
<pre class="src src-bash">export LK_DIR=/tmp/linkspace
lk --init key --decrypt-cost 0 --password "my secret" # remove the --decrypt-cost. it speeds up building this doc
</pre>
</div>

<pre class="example" id="org52f241e">
$argon2d$v=19$m=8,t=1,p=1$4aR+SwF+z9xQh/+HInalukDyXJavvxy5R8tju+mx7yY$DQf/5jEV7INcBRjLOdSnZBVzH8MTN06j2GFQB1iBSKE
4aR-SwF-z9xQh_-HInalukDyXJavvxy5R8tju-mx7yY
</pre>

<div class="org-src-container">
<pre class="src src-bash">lk keypoint "example::" --password "my secret" | lk pktf
</pre>
</div>

<pre class="example" id="org387784c">
type	KeyPoint
hash	M0EwF90sY2u1GmxSGzYnjNCjzHIQt-194EyBXkVxMYc
group	[#:pub]
domain	example
space	
pubkey	[@:me:local]
create	1696258157493063
links	0

data	0
</pre>

<p class="verse">
The CLI also accepts <code>lk link --sign</code> instead of <code>lk keypoint</code><br>
</p>

</div>
<div class="py" id="orgc7b510a">
<div class="org-src-container">
<pre class="src src-python">lk = lk_open("/tmp/linkspace",create=True)
key = lk_key(lk,b"my secret");
example_keypoint = lk_keypoint(key=key,domain=b"example")
str(example_keypoint)
</pre>
</div>

</div>

</div>
</div>
</div>



<div id="outline-container-org4664cde" class="outline-3">
<h3 id="org4664cde">Fields</h3>
<div class="outline-text-3" id="text-org4664cde">
<p>
In python you can access these fields directly as bytes.
Fields are not writable because they are included in the hash.
</p>

<div class="org-src-container">
<pre class="src src-python">[attr for attr in dir(lk_linkpoint())  if not "__" in attr]
</pre>
</div>

<p>
Where spacename[0..7] are the spacename components, 
</p>

<p class="verse">
Some <a href="#predicatelist">fields</a> we've not seen so far are writable, but they are not relevant for most applications.<br>
</p>
</div>
</div>


<div id="outline-container-org668f791" class="outline-3">
<h3 id="org668f791">Notes</h3>
<div class="outline-text-3" id="text-org668f791">
<p>
Groups signals the intended set of recipients.
Domains signal the activity, and practically the application used to present an interface to the user.
</p>

<p>
The groups bytes can be chosen arbitrarily. Membership is enforced by its members.
It's up to the user (or some management tool) to pick a method of data exchange.
</p>

<p>
The following do have a meaning.
The [0;32] null group ( <code>[#:0]</code> ), i.e. the local only group, is never transmitted to other devices and is never accepted from outside sources.
Everything in the <code>[#:pub]</code> group<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> is meant for everybody. e.g. the public.
</p>

<p>
By convention the group created by pubkey1 XOR pubkey2 forms a group with those keys as its only two members.
</p>

<p class="verse">
The <code>[#:...]</code> is part of the <a href="#lns">LNS</a>.<br>
A public registry for assigning names and naming rights.<br>
e.g. <code>[#:sales:mycomp:com]</code> for groups and <code>[@:alicekey:mycomp:com]</code> for keys.<br>
</p>
</div>
</div>


<div id="outline-container-packet_layout" class="outline-3">
<h3 id="packet_layout">lk_write and lk_read</h3>
<div class="outline-text-3" id="text-packet_layout">
<p>
The point is the content that is hashed, the packet is the a mutable network header, the hash, and the point.
</p>

<div class="ctabs" id="org599e09b">
<div class="py" id="orgd502965">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">datap = lk_datapoint("hello")
linkp = lk_linkpoint()
keyp = lk_keypoint(key)
packet_bytes = lk_write(datap) + lk_write(linkp) + lk_write(keyp)
print(len(packet_bytes),packet_bytes)

# read the bytes as packets
(p1, packet_bytes)= lk_read(packet_bytes)
(p2, packet_bytes)= lk_read(packet_bytes)
(p3, packet_bytes)= lk_read(packet_bytes)

assert(p1 == datap)
assert(p2 == linkp)
assert(p3 == keyp)
</pre>
</div>

</div>
<div class="bash" id="orgc17aa1f">
<p>

</p>


<p>
The CLI automatically reads and writes in packet format from the relevant pipes.
</p>
<div class="org-src-container">
<pre class="src src-bash">echo datapoint:
echo -n hello | lk data | tee /tmp/pkts | xxd 
echo linkpoint:
echo -n hello | lk link my_domain:[#:pub]:/hello/world -- link1:[#:0] link2:[#:test] | tee -a /tmp/pkts | xxd 
echo keypoint:
echo -n hello | lk keypoint --password "my secret" my_domain:[#:pub]:/hello/world -- link1:[#:0] link2:[#:test] | tee -a /tmp/pkts | xxd 
cat /tmp/pkts | lk pktf [hash:str]
</pre>
</div>

<pre class="example" id="org61e526f">
datapoint:
00000000: 4c4b 3100 0000 0000 ffff ffff ffff ffff  LK1.............
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0f97 62e5 8ed1 502f dea8 c915 63c4 ce00  ..b...P/....c...
00000030: 51af f41f 8f40 6f63 31ad 8626 3366 0301  Q....@oc1..&amp;3f..
00000040: 0001 0009 6865 6c6c 6fff ffff ffff ffff  ....hello.......
linkpoint:
00000000: 4c4b 3100 0000 0000 ffff ffff ffff ffff  LK1.............
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 2fd5 9257 f6c2 764e 2f35 309b 918e 5c4a  /..W..vN/50...\J
00000030: 635a c093 a8f4 0afb c9f5 197f 6206 d537  cZ..........b..7
00000040: 0003 00b4 00a0 00b4 0006 06bc e0f1 566f  ..............Vo
00000050: 62bb 3b8b 3dd5 ce75 e1fa 882f e1a3 3ad9  b.;.=..u.../..:.
00000060: 598c 3715 c589 3e0f db8b 487d 5cfd b139  Y.7...&gt;...H}\..9
00000070: 0000 0000 0000 006d 795f 646f 6d61 696e  .......my_domain
00000080: 0000 0000 0000 0000 0000 006c 696e 6b31  ...........link1
00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000b0: 0000 0000 0000 0000 0000 006c 696e 6b32  ...........link2
000000c0: 2d1b f1bc 0f64 246e 3485 65a5 5b0a 9198  -....d$n4.e.[...
000000d0: b02b 33ce dc82 bfb0 56c2 4741 85b4 367c  .+3.....V.GA..6|
000000e0: 0206 0c0c 0c0c 0c0c 0568 656c 6c6f 0577  .........hello.w
000000f0: 6f72 6c64 ffff ffff                      orld....
keypoint:
00000000: 4c4b 3100 0000 0000 ffff ffff ffff ffff  LK1.............
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 600d 8a98 a631 96b5 9427 91e9 0531 affc  `....1...'...1..
00000030: 2a14 1019 6794 553b cde5 e6d3 1d62 6f98  *...g.U;.....bo.
00000040: 0007 0114 00a0 00b4 0006 06bc e0f1 7c1f  ..............|.
00000050: 62bb 3b8b 3dd5 ce75 e1fa 882f e1a3 3ad9  b.;.=..u.../..:.
00000060: 598c 3715 c589 3e0f db8b 487d 5cfd b139  Y.7...&gt;...H}\..9
00000070: 0000 0000 0000 006d 795f 646f 6d61 696e  .......my_domain
00000080: 0000 0000 0000 0000 0000 006c 696e 6b31  ...........link1
00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000b0: 0000 0000 0000 0000 0000 006c 696e 6b32  ...........link2
000000c0: 2d1b f1bc 0f64 246e 3485 65a5 5b0a 9198  -....d$n4.e.[...
000000d0: b02b 33ce dc82 bfb0 56c2 4741 85b4 367c  .+3.....V.GA..6|
000000e0: 0206 0c0c 0c0c 0c0c 0568 656c 6c6f 0577  .........hello.w
000000f0: 6f72 6c64 ffff ffff e1a4 7e4b 017e cfdc  orld......~K.~..
00000100: 5087 ff87 2276 a5ba 40f2 5c96 afbf 1cb9  P..."v..@.\.....
00000110: 47cb 63bb e9b1 ef26 a4da cc2f 5ad3 35bb  G.c....&amp;.../Z.5.
00000120: 3815 0990 bf21 ec3a 83f0 fd2d 45f6 dac5  8....!.:...-E...
00000130: 9848 04ed f7d7 a357 4ded 8a88 5a8e 87ed  .H.....WM...Z...
00000140: 3faf 6f9e ae14 a745 79ce 9ad4 d63d 9860  ?.o....Ey....=.`
00000150: 16f9 e9d9 d201 ad17                      ........
D5di5Y7RUC_eqMkVY8TOAFGv9B-PQG9jMa2GJjNmAwE
L9WSV_bCdk4vNTCbkY5cSmNawJOo9Ar7yfUZf2IG1Tc
YA2KmKYxlrWUJ5HpBTGv_CoUEBlnlFU7zeXm0x1ib5g
</pre>

</div>

</div>

<p>
Linkspace can be used in two general ways. A classic client/server where you control the entire network. 
Or in full distributed mode where each user manages their own runtime.
In the latter, an application does not have to deal with IO sockets directly.
</p>
</div>
</div>
</div>

<div id="outline-container-ABE" class="outline-2">
<h2 id="ABE">ABE</h2>
<div class="outline-text-2" id="text-ABE">
<p class="verse">
<a href="../docs/rust/linkspace/abe/index.html">Rust docs</a><br>
</p>

<p>
ABE (Ascii-Byte-Expr) is a tiny language-agnostic byte templating engine.
Its core structure is a stringly representation of delimited bytes ( of the type: <code>[ ( [u8], delimiter ) ]</code> ).
Its primary purpose is to make it easy (for developers) to read and write sequences of bytes (0..=255) in plain ascii, including the <code>null</code> (0) byte.
In addition, it supports evaluation of functions that act as shorthand for long sequences of bytes. 
</p>

<p>
Linkspace packets have no concept of encoding formats.
All fields are fixed length or prefix their exact length.
</p>

<p>
ABE is used for things like <a href="#Query">Query</a>, <a href="#org5717c23">printing</a>, and in most arguments for the cli.
</p>

<p>
ABE is not meant to be a programming language!
It's primarily meant to read and write arbitrary bytes in some context and quickly beat them into a desired shape.
Some things are limited by design.
If there is no obvious way to do something use a general purpose language to deal with your use-case.
</p>

<p>
When building an application you can choose where to use ABE and when to use a different encoding.
</p>
</div>

<div id="outline-container-orge2b5cbd" class="outline-3">
<h3 id="orge2b5cbd">Basic Encoding</h3>
<div class="outline-text-3" id="text-orge2b5cbd">
<ul class="org-ul">
<li>Most printable ascii letters are as is.</li>
<li>Newline is an external delimiters.</li>
<li><code>:</code> and <code>/</code> are internal delimiters. Separating two byte expressions.</li>
<li><code>[</code> and <code>]</code> wrap an expression</li>
<li><code>:</code>, <code>/</code>, <code>\</code>, <code>[</code>, <code>]</code>  can be escaped with a <code>\</code>.</li>
<li><code>\x00</code> up-to <code>\xFF</code> for bytes.</li>
<li><code>\0</code> equals  <code>\x00</code>,  <code>\f</code> equals <code>\xFF</code></li>
</ul>

<p>
We can encode binary into valid abtxt as follows:
</p>

<p class="verse">
We'll get back to <a href="#lk_encode">encode</a> more in depth later.<br>
</p>

<div class="ctabs" id="org4e3cd5a">
<div class="bash" id="orga9f2649">
<div class="org-src-container">
<pre class="src src-bash">printf "hello" | lk encode -i
printf "world/" | lk encode -i
printf "nl \n" | lk encode -i
printf "open [ close ]" | lk encode -i
printf "emoji ⌨" | lk encode -i
</pre>
</div>

</div>

<div class="py" id="org2d259be">
<p>
All fields are arbitrary bytes, and lk_encode can print them as ab text
</p>

<div class="org-src-container">
<pre class="src src-python">multiline = """newline
tab	""".encode() # encode implies utf-8

lkp = lk_linkpoint(spacename=[b"hello",b"world/",multiline,b"open [ close ]"])

print(lk_encode(lkp.comp0),"\t",list(lkp.comp0))
print(lk_encode(lkp.comp1),"\t",list(lkp.comp1))
print(lk_encode(lkp.comp2),"\t",list(lkp.comp2))
print(lk_encode(lkp.comp3),"\t",list(lkp.comp3))
print(lk_encode(lkp.comp4),"\t",list(lkp.comp4), lkp.comp4.decode("utf-8"))
</pre>
</div>

</div>

</div>
</div>
</div>

<div id="outline-container-org381da7a" class="outline-3">
<h3 id="org381da7a">lk_eval</h3>
<div class="outline-text-3" id="text-org381da7a">
<p>
ABE is evaluated by substituting an expressions ( <code>[..]</code> ) with its result.
For example in <code>[u8:97]</code>, the function 'u8' is called with the arguments ["97"].
The function 'u8' reads the decimal string and writes it as a byte.
The byte 97 equals the character 'a'. The byte 99 equals the byte 'c'
</p>

<div class="org-src-container">
<pre class="src src-bash">lk eval "ab[u8:99]" | xxd
</pre>
</div>

<pre class="example" id="org2ba6d19">
00000000: 6162 63                                  abc
</pre>

<div class="org-src-container">
<pre class="src src-bash">lk eval --json "h[u8:101]ll[u8:111] / world:etc" 
</pre>
</div>

<pre class="example" id="org423ac7d">
[[null,"hello "],["/"," world"],[":","etc"]]
</pre>

<p>
Note that bytes are joined after evaluating. In the example this results in <code>h</code> + <code>e</code> + <code>ll</code> + <code>o</code> + <code>' '</code> =&gt; <code>'hello '</code>.
The meaning of the delimiters ('\n', ':', '/') are interpreted depending on the context.
For instance, <code>lk eval</code> prints them 'as is' for the outer expression.
</p>


<p class="verse">
The rest of this chapter explains ABE further in depth.<br>
<br>
The ABE functions can shorten your code, and almost every CLI argument is an ABE expression.<br>
These expressions can directly refer to the context, such as a <a href="#pkt-scope">packet</a>.<br>
This makes ABE a powerful tool.<br>
<br>
But knowing all of ABE's features it not required to use linkspace.<br>
<br>
ABE a language of convenience.<br>
<br>
With basic knowledge of its purpose to read and write separated bytes (i.e. <code>[ [u8] ]</code>), expression substitution (<code>[..]</code>), and the <code>':'</code>, <code>'/'</code> delimiters,<br>
the rest of the guide (starting at <a href="#Query">Query</a>) can be read while you return here for reference in case something is unclear.<br>
</p>


<p>
There are two modes for tokenizing (before evaluation).
</p>
<ul class="org-ul">
<li>Strict: <code>\n</code>, <code>\t</code>, <code>\r</code> and bytes outside the range 0x20(SPACE)..=0x7e(~) are escaped.</li>
<li>Parse Unencoded: bytes outside 0x20..=0x7e are read 'as-is'.</li>
</ul>

<p>
Both error when bytes are incorrectly escaped or non-closed <code>[</code>, <code>]</code> brackets exists.
</p>
</div>

<div id="outline-container-org592c454" class="outline-4">
<h4 id="org592c454">Sub-expressions</h4>
<div class="outline-text-4" id="text-org592c454">
<p>
A list of functions/macros be found by evaluating
<a href="#abe-help">[[help</a>][\[help\]]].
</p>
</div>

<div id="outline-container-org404e6b9" class="outline-5">
<h5 id="org404e6b9">Functions</h5>
<div class="outline-text-5" id="text-org404e6b9">
<ul class="org-ul">
<li><code>[fn]</code></li>
<li><code>[fn:arg0]</code></li>
<li><code>[fn:arg0:arg1]</code></li>
</ul>

<p>
The arguments are plain bytes. A function can take upto 8 arguments.
Usually the results is concatenated with its surrounding bytes.
The empty function <code>'[:...]'</code> resolves to its first argument.
</p>

<ul class="org-ul">
<li><code>hello [:world]</code> == <code>hello world</code></li>
</ul>

<p>
Arguments are evaluated before application.
<code>[fn0:[fn1]]</code> will call fn1 and use its result as the first argument to fn0.
</p>

<p>
You can chain results with <code>/</code>.
It uses the result as the first argument to the next function.
</p>

<ul class="org-ul">
<li><code>[:97/u8]</code> <code>= ~[u8:97]~ =</code> <code>a</code></li>
<li><code>[:97/u8/?u]</code> <code>= ~[?u:[u8:97]]~ =</code> <code>97</code></li>
</ul>

<p>
You can think of ABE functions as a translation of conventional function calling.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>[name:arg1:arg2]</code></td>
<td class="org-left"><code>name(arg1,arg2)</code></td>
</tr>

<tr>
<td class="org-left"><code>[name:[other_name:argA]:arg2]</code></td>
<td class="org-left"><code>name( other_name(argA) , arg2 )</code></td>
</tr>

<tr>
<td class="org-left"><code>[other_name:argA/name:arg2]</code></td>
<td class="org-left"><code>name ( other_name(argA) , arg2 )</code></td>
</tr>
</tbody>
</table>

<p class="verse">
Functions are aware if they are first or not.<br>
The vast majority of functions do not care.<br>
</p>

<p class="verse">
<code>[[:u8]:97]</code> is explicitly not allowed. Variable function identifiers are conceptually interesting but practically begging for bugs.<br>
</p>

<p>
Note: describing ABE can be a bit tricky in relation to conventional languages.
Specifically, there is no syntax to "reference" a function, they are always resolved to their result.
i.e. <code>fn name(){..}; let x = name; let y = name();</code> has the <code>()</code> syntax to differentiate between calling a function or referencing a value.
There are no 'variables' by design, because ABE is not meant to be used that way.
</p>
</div>
</div>


<div id="outline-container-org120c247" class="outline-5">
<h5 id="org120c247">Macros</h5>
<div class="outline-text-5" id="text-org120c247">
<p>
The second type of operation is applying a macro.
Whereas functions are called after their arguments are evaluated.
Macros are called <span class="underline">as is</span> up until its matching ']' without evaluation <code>[..]</code> expressions.
</p>

<ul class="org-ul">
<li><code>[/a_macro]</code></li>
<li><code>[/a_macro:arg0:arg1]</code></li>
<li><code>[/a_macro:[fn:arg0]:arg1/hello]</code></li>
</ul>

<p>
The <code>/a_macro</code> macro operates on <code>:[fn:arg0]:arg1/hello</code> without it being evaluated.
</p>
</div>
</div>
</div>


<div id="outline-container-scope" class="outline-4">
<h4 id="scope">Scope &amp; Context</h4>
<div class="outline-text-4" id="text-scope">
<p>
Functions and Macros are defined in a scope.
Scopes can be chained, so that if no matching function is found it looks in the next scope. 
The standard scope chain has multiple functions and macros to manipulate bytes.
You can see all active scopes with the [help] function.
</p>

<p>
Sometimes the scope chain is extended with additional context: 
</p>
</div>

<div id="outline-container-org87cb53c" class="outline-5">
<h5 id="org87cb53c">Argv</h5>
<div class="outline-text-5" id="text-org87cb53c">
<p>
A scope containing functions resolving to an argument vector. 
</p>

<div class="ctabs" id="orgd8e6283">
<div class="py" id="org76f3046">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">inp = "Rm9ycmVzdA" # the base 64 encoding of the word "Forrest"
lk_eval("[0] [1/b], [0]!",argv=["Run",inp])
</pre>
</div>

</div>

</div>
</div>
</div>

<div id="outline-container-pkt-scope" class="outline-5">
<h5 id="pkt-scope">Packet</h5>
<div class="outline-text-5" id="text-pkt-scope">
<p>
By providing a packet, the packet scope is added to the chain.
This adds functions such as <code>hash</code>, <code>group</code>, <code>spacename</code> etc.
These are bytes that you can use as arguments.
</p>

<p>
e.g <code>[hash/?b]</code> encodes the hash in base 64.
</p>

<p>
For convenience all packet fields accept 'str' and 'abe' as a first argument to print them in a default format.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>[hash:str]</code></td>
<td class="org-left"><code>[hash/?b]</code></td>
</tr>

<tr>
<td class="org-left"><code>[group:str]</code></td>
<td class="org-left"><code>[group/?b]</code></td>
</tr>

<tr>
<td class="org-left"><code>[create:str]</code></td>
<td class="org-left"><code>[create/?u]</code></td>
</tr>

<tr>
<td class="org-left"><code>[links_len:str]</code></td>
<td class="org-left"><code>[links_len/?u]</code></td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
The <code>[/links:...]</code> macro iterates over every link in a packet.
It evaluates the inner scope for each link with setting the <code>tag</code> and <code>ptr</code> function.
</p>

<div class="ctabs" id="org9a9f1c6">
<div class="sh" id="org1ec435e">
<p>
<code>pktf</code> is <code>eval</code> that reads packets from stdin and puts them in scope.
</p>

<div class="org-src-container">
<pre class="src src-bash">lk link "::" -- tag1:[#:0] tag2:[#:pub] | \
    lk pktf "HASH:[hash/?b]\n[/links:TAG = [tag:str] PTR = [ptr:str] \n]"
</pre>
</div>

<pre class="example" id="org2ae5354">
HASH:Q_K9Wws05PpBkkY4JajnyCgl9KtFmJhXH7OWF7xQS9A
TAG = tag1 PTR = AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
TAG = tag2 PTR = Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk
</pre>

</div>

<div class="py" id="org757dab6">
<div class="org-src-container">
<pre class="src src-python">lp = lk_linkpoint(links=[Link("hello",PUBLIC),Link("world",PRIVATE)])
lk_eval2str("hash:[hash:str]\\n[/links:[tag:str] [ptr:str]\\n]",pkt=lp)
</pre>
</div>

</div>

</div>
</div>
</div>

<div id="outline-container-org71f9d24" class="outline-5">
<h5 id="org71f9d24">Runtime</h5>
<div class="outline-text-5" id="text-org71f9d24">
<p>
Having a linkspace runtime in the scope gives you access to functions like:
</p>

<ul class="org-ul">
<li><code>#</code> and <code>@</code> ( see <a href="#lns">LNS</a> ) for named groups, keys, and other data</li>
<li><code>readhash</code></li>
</ul>

<p>
The first instance of <a href="#lk_open">lk_open</a> is used in the default (thread local).
</p>

<p>
<code>readhash</code> is considered bad practice, fine to hack something together, but it doesn't give you much room to process errors or async.
But you can do some wizardry combining it with <code>[/links]</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc3c7a86" class="outline-4">
<h4 id="orgc3c7a86">Usage notes</h4>
<div class="outline-text-4" id="text-orgc3c7a86">
<p>
ABE expressions evaluate into a list of [ (?sep,bytes) ].
Sometimes each element has a different meaning, e.g. [ ( 0, domain ) , ( :,  group) ] in the CLI arguments.
You can process this list with <code>lk_tokenize_abe</code>. 
</p>

<p>
But in the majority of cases we don't care about the list and only want a single result.
<code>lk_eval</code> does just that. It interprets the separators as plain characters.
</p>

<p>
Finally, consider what you would expect to happen when an macro takes a ABE expression as its final argument:
</p>

<ul class="org-ul">
<li><code>[/links:abc[:hello]/world]</code></li>
<li><code>[/readhash:[#:pub]:the pkt:[pkt]]</code></li>
<li><code>[/:hello/world]</code></li>
<li id="~lk link">&#x2013;write 'file:./afolder:with/colons'~</li>
</ul>

<p>
The choice was made that if the final argument is an abe expression that will be evaluated, it doesn't need wrapping <code>[]</code>.
Instead, it interprets the entire tail as is.
This reduces the need to escape ':' and '/', but complicating some other expressions.
</p>

<p class="verse">
We can add an expression to &#x2013;write arguments<br>
<code>lk link :: --write "stdout-expr:hello world:/ [hash:str]"</code><br>
In case of <code>file</code> this leaves us in the situation that second argument is the file and the tail of the expression will be evaluated<br>
One option is to use <code>[/:..]</code> to read ':' and '<i>' as is.<br>
~lk link :: &#x2013;write "file-expr:[</i>:./afolder:with/colons]:hello world:/ [hash:str]"~<br>
</p>
</div>
</div>


<div id="outline-container-abe-help" class="outline-4">
<h4 id="abe-help">Help</h4>
<div class="outline-text-4" id="text-abe-help">
<p>
A full list of active scopes can be viewed with the <code>help</code> function.
</p>
<div class="ctabs" id="org66d28d0">
<div class="misc" id="org0172345">
<p class="verse">
The following naming conventions are used:<br>
<br>
- ending with '?' is a predicate to check a property.<br>
- starting with '?' is a basic reverse operation. [u8:97/?u] == 97. Its similar but less powerful then <a href="#lk_encode">lk_encode</a> and lacking '[]' brackets.<br>
- b_RADIX_ ( b2, b8, b16 ) 'b' defaults to base64 radix<br>
- u_SIZE_  ( u8, .., u128 ) parse decimal into big endian bytes. ?u interpret as big endian print to decimal<br>
</p>

</div>

<div class="py" id="org054fb3c">
<div class="org-src-container">
<pre class="src src-python">lk_eval2str("[help]",pkt=lk_linkpoint(),argv=["hello"]) # the help won't show up if no scope is set. 
</pre>
</div>

</div>

</div>
</div>
</div>
</div>

<div id="outline-container-lk_encode" class="outline-3">
<h3 id="lk_encode">lk_encode</h3>
<div class="outline-text-3" id="text-lk_encode">
<p>
Translate bytes into abe such that <code>lk_eval(lk_encode(X)) == X</code>
</p>

<p class="verse">
We can get meta. lk_encode is available as the macro <code>[/?:bytes:options]</code><br>
</p>

<div class="ctabs" id="orgc6c43f5">
<div class="py" id="org17ca4c4">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">data = bytes([0,0,0,255])
abe = lk_encode(data)
assert data == lk_eval(abe)
print("ab  text:", abe)
abe = lk_encode(data,"u8/u32/b") # Try to encode as expression
print("abe text:", abe)
</pre>
</div>

</div>

</div>
</div>

<div id="outline-container-org5717c23" class="outline-4">
<h4 id="org5717c23">DEFAULT_FMT</h4>
<div class="outline-text-4" id="text-org5717c23">
<p>
This is how packets are printed by default using <code>lk pktf</code> or pythons <code>str(pkt)</code>.
</p>

<div class="ctabs" id="orgff28b69">
<div class="py" id="org2aedd5c">
<div class="org-src-container">
<pre class="src src-python">import linkspace
print(linkspace.DEFAULT_PKT)
</pre>
</div>

</div>

</div>
</div>
</div>
</div>


<div id="outline-container-lk_tokenize_abe" class="outline-3">
<h3 id="lk_tokenize_abe">lk_tokenize_abe</h3>
<div class="outline-text-3" id="text-lk_tokenize_abe">
</div>
</div>



<div id="outline-container-ABELNS" class="outline-3">
<h3 id="ABELNS">LNS</h3>
<div class="outline-text-3" id="text-ABELNS">
<p>
LNS is a system for publicly naming keys and groups, and adding auxiliary data to them.
It allows you to register as <code>@:Alice:nl</code>, <code>#:sales:company:com</code>, etc.
</p>

<p>
LNS is easy to use from an abe expression.
Both to lookup and do a reverse lookup.
</p>

<p>
See <a href="../../lns.html">lns</a> for info.
</p>

<p class="verse">
You can create local bindings, allowing you to reference <code>[@:my_identity:local]</code> or <code>[#:friends:local]</code><br>
By default <a href="#lk_key">lk_key</a> sets up the <code>[@:me:local]</code> identity.<br>
</p>

<div class="ctabs" id="org4240f70">
<div class="sh" id="org0133c93">
<div class="org-src-container">
<pre class="src src-bash">lk eval "[#:pub]" | lk encode "@/#/b"
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">lk eval "[@:me:local]" | lk encode "@/#/b"
</pre>
</div>

</div>

<div class="py" id="org9349504">
<div class="org-src-container">
<pre class="src src-python">group = example_keypoint.group
print("The bare bytes:", group)

# encode as b64
b64 = lk_encode(group,"b")
print("b64 encoded   :", b64)

# Try to express as a [#:..], on failure try as [@:..], fallback to [b:...]
try_name = lk_encode(group,"#/@/b")
print("Or through lns:", try_name)

print("Pkt's pubkey  :",example_keypoint.pubkey)
try_keyname = lk_encode(example_keypoint.pubkey,"#/@/b")
print("Similarly lns :", try_keyname)


</pre>
</div>

</div>

</div>
</div>
</div>
</div>


<div id="outline-container-Query" class="outline-2">
<h2 id="Query">Query</h2>
<div class="outline-text-2" id="text-Query">
<p class="verse">
<a href="../docs/rust/linkspace/query/index.html">Rust docs</a><br>
</p>

<p>
A query is a list of predicates and options used to define a set of packets.
They're used in various ways, most notably you can use them to read (<a href="#lk_get">lk_get</a>, <a href="#lk_get_all">lk_get_all</a>), await (<a href="#lk_watch">lk_watch</a>) and request (<a href="#lk_pull">lk_pull</a>) packets.
</p>
</div>

<div id="outline-container-lk_query" class="outline-3">
<h3 id="lk_query">lk_query</h3>
<div class="outline-text-3" id="text-lk_query">
<p>
Queries are newline separated.
Predicates are an <a href="#ABE">ABE</a> 3-tuple <code>field ':' test-operation ':' value</code> and constrain the set of accepted packets.
Options are context dependent and start with ':'
</p>

<p>
A query might look like this:
</p>

<pre class="example" id="orgcfb79cd">
group:=:[#:pub]
domain:=:example
spacename:=:/hello/world
pubkey:=:[@:me:local]
create:&gt;:[now:-1D]
</pre>

<p>
A predicate can be set multiple times. In the example above we could add <code>create:&lt;:[now:+2D]</code> to constrain it further.
Queries are designed such that you can concatenate their strings and get their union.
If the result is the empty set an error is returned.
</p>

<p>
There are 4 basic test operations and a couple of aliases.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Basic Op</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&gt;</td>
<td class="org-left">greater eq</td>
</tr>

<tr>
<td class="org-left">&lt;</td>
<td class="org-left">less eq</td>
</tr>

<tr>
<td class="org-left">0</td>
<td class="org-left">all '0' in value are '0' in field</td>
</tr>

<tr>
<td class="org-left">1</td>
<td class="org-left">all '1' in value are '1' in field</td>
</tr>
</tbody>
</table>

<p>
The following are shorthand and resolve to one or more of the basic tests.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Derived Ops</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">=</td>
<td class="org-left">&gt;(val-1) and &lt;(val+1)</td>
</tr>

<tr>
<td class="org-left">&gt;=</td>
<td class="org-left">&gt;(val-1)</td>
</tr>

<tr>
<td class="org-left">&lt;=</td>
<td class="org-left">&lt;(val+1)</td>
</tr>

<tr>
<td class="org-left">*=</td>
<td class="org-left">Last n-bytes must eq val</td>
</tr>

<tr>
<td class="org-left">=*</td>
<td class="org-left">First n-bytes must eq val</td>
</tr>
</tbody>
</table>



<div class="ctabs" id="orge69f8fe">
<div class="sh" id="org824c5c5">
<p>

</p>

<p>
The CLI has options that can act as a guide in creating queries by using <code>lk print-query --help</code>.
</p>

<p class="verse">
Many cli commands (e.g. <code>print-statemnt</code>, <code>watch</code> ) take as the first argument a <code>domain:group:spacename:(?depth)</code><br>
If no depth is set the depth is constraint by default.<br>
Except for <code>watch-tree</code> which sets the depth to unconstrained by default<br>
</p>

<p>
Here we look for the domain 'my' , the group [#:pub], with spacename starting at /hello and with one additional spacename component.
</p>

<div class="org-src-container">
<pre class="src src-bash">lk print-query "my:[#:pub]:/hello:*" --signed
</pre>
</div>

<pre class="example" id="org0ef76ef">
:mode:tree-desc
type:1:[b2:00000111]
domain:=:[a:my]
group:=:[b:Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk]
prefix:=:/hello
depth:&lt;:[u8:3]
depth:&gt;:[u8:0]
</pre>

</div>

<div class="py" id="org894eff4">
<div class="org-src-container">
<pre class="src src-python">template = lk_query_parse(lk_query(),"group:=:[#:pub]")
a_copy = lk_query(template)
lk_query_print(a_copy)
</pre>
</div>

</div>

</div>
</div>
</div>

<div id="outline-container-lk_query_parse" class="outline-3">
<h3 id="lk_query_parse">lk_query_parse</h3>
<div class="outline-text-3" id="text-lk_query_parse">
<p>
Add multiple constraints to a query.
You can add multi line strings or per line.
Each line is evaluated as an abe expression.
You can set a pkt or argv context.
</p>

<p>
Returns an error if the resulting set is empty.
The full list of predicates and their byte size can be found <a href="#predicatelist">here</a>.
</p>

<div class="ctabs" id="org39a727f">
<div class="py" id="orga348cb2">
<div class="org-src-container">
<pre class="src src-python">q = lk_query()

stmt = """
group:=:[#:pub]
domain:=:example
"""

q = lk_query_parse(q,stmt,
               "depth:&lt;:[u8:4]",
               "data_size:&lt;:[0]",argv=[int(10).to_bytes(2)]) 
lk_query_print(q,True)
</pre>
</div>

</div>

</div>
</div>
</div>

<div id="outline-container-lk_query_push" class="outline-3">
<h3 id="lk_query_push">lk_query_push</h3>
<div class="outline-text-3" id="text-lk_query_push">
<p>
Similar to lk_query_parse, but only adds a single statement and the last field expects the bytes.
</p>

<div class="ctabs" id="orgece3e67">
<div class="py" id="orgbaaeab4">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">q = lk_query()
q = lk_query_push(q,"data_size","&lt;",bytes([0,4])) # less than 4
q = lk_query_push(q,"data_size","&lt;",lk_eval("[u16:20]"))  # less than 20
q = lk_query_push(q,"data_size","&lt;",int(3).to_bytes(2))  # less than 3
lk_query_print(q)
</pre>
</div>

<p>
Adding a contradictions returns an error.
</p>

<div class="org-src-container">
<pre class="src src-python">try:
  r = lk_query_push(q,"data_size","&gt;",bytes([0,100])) # greater than 100 and smaller than 3 can not both be true
except Exception as e :
  r = ("That's not possible",e)
r

</pre>
</div>

<pre class="example" id="org1794899">
("That's not possible", NameError("name 'lk_query_push' is not defined"))
</pre>

</div>

</div>
</div>
</div>


<div id="outline-container-lk_query_print" class="outline-3">
<h3 id="lk_query_print">lk_query_print</h3>
<div class="outline-text-3" id="text-lk_query_print">
<p>
Print a query as text.
The query will have merged overlapping predicates
The boolean argument sets whether to create abe expressions or stick to a representation without expressions.
</p>

<div class="ctabs" id="org2459efb">
<div class="py" id="org184ea89">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">lk_query_print(q,True)
</pre>
</div>

</div>

</div>


<p class="verse">
The <code>b2</code> function read a binary representation.<br>
The types are: datapoint=[b2:0000_0001], linkpoint [b2:0000_0011], keypoint [b2:0000_0111].<br>
Setting 'group', 'domain', 'spacename', 'links', or 'create' predicates automatically exclude the datapoint type.<br>
Setting pubkey or signature excludes link and data points.<br>
</p>
</div>
</div>

<div id="outline-container-orgedcb4d4" class="outline-3">
<h3 id="orgedcb4d4">More on predicates</h3>
<div class="outline-text-3" id="text-orgedcb4d4">
<p class="verse">
<code>group</code> requires 32 bytes but will try to parse base64.<br>
<code>domain</code> requires 16 bytes but will prepend '\0' if too few bytes are given<br>
<code>spacename</code> and <code>prefix</code> only take the = op. Their value is the bytes <code>spacename:=:[//hello/world]</code>, but they'll accept <code>/hello/world</code> as well<br>
</p>

<p>
Besides the fields in a point, predicates also apply to the hash and variable net header fields.
</p>

<p>
The netheader fields can be mutated, and are stored in the database when a packet is first written.
Domain applications should avoid these fields. They are used when writing an exchange process.
(For more notes on that see dev/exchange.md)
</p>

<p>
The netheader is 32 bytes which are named: 
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>

<tr>
<th scope="col" class="org-left">Field<sub>size</sub></th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Prefix<sub>3</sub></td>
<td class="org-left">magic bytes 'LK1'</td>
</tr>

<tr>
<td class="org-left">NetFlags<sub>1</sub></td>
<td class="org-left">See source code</td>
</tr>

<tr>
<td class="org-left">hop<sub>2</sub></td>
<td class="org-left">number of hops since creation</td>
</tr>

<tr>
<td class="org-left">stamp<sub>8</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits0<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits1<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits2<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits3<sub>4</sub></td>
<td class="org-left">RESERVED</td>
</tr>
</tbody>
</table>

<p>
Except for the prefix and ubits3.
</p>
</div>

<div id="outline-container-orgedb0679" class="outline-4">
<h4 id="orgedb0679">Recv</h4>
<div class="outline-text-4" id="text-orgedb0679">
<p>
The final predicate is 'recv'. This is a 8 byte stamp for when the packets was first read.
It can be used to filter such as <code>recv:&gt;:[now:-1D]</code>.
</p>

<p>
It is considered bad design for applications to depend on this.
They should use the <code>create</code> stamp to avoid depending on any group-exchange specific behavior.
</p>

<p>
The recv predicate depends on the context. 
Reading from the database the recv is set to the time the packet was received:  <code>lk watch-log --bare -- "recv:&gt;:[now:-1D]"</code>
But when reading from a pipe it is set to when the pipe reads the packet: <code>lk watch-log | lk filter "recv:&gt;:[now:-1D]"</code>
</p>

<p>
In both cases the predicate <code>recv:&lt;:[now:+1m]</code> would stop the process after 1 minute.
</p>
</div>
</div>
</div>

<div id="outline-container-orgff09b95" class="outline-3">
<h3 id="orgff09b95">Options</h3>
<div class="outline-text-3" id="text-orgff09b95">
<p>
Options are additional configurations for a set of predicates.
</p>

<p>
They are of the form <code>':' name ':' rest</code>. 
Depending on the context/function they are ignored.
Developers are free to expand their meaning for their usecase like in a group exchange processes. 
</p>

<p>
Unlike predicates, options have no standard meaning when two queries with the same option are concatenated.
Predicates have a well defined meaning when queries are concatenated.
Options should define their own logic when they appear multiple times.
</p>

<p>
The following options are known to have a specific meaning:
</p>

<p>
NOTE: These options will change somewhat in coming versions. 
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">name</th>
<th scope="col" class="org-left">value</th>
<th scope="col" class="org-left">use</th>
<th scope="col" class="org-left">multiple</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">:mode:</td>
<td class="org-left">(tree/hash/log)-(asc/desc)</td>
<td class="org-left">set the table to read from</td>
<td class="org-left">Last is used</td>
</tr>

<tr>
<td class="org-left">:follow</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">also output linked packets</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">:qid:</td>
<td class="org-left">&lt;any&gt;</td>
<td class="org-left">identity/close an active query</td>
<td class="org-left">Last is used</td>
</tr>

<tr>
<td class="org-left">:notify-close</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">send a final dummy packet when closing a query</td>
<td class="org-left">N/A</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-predicatelist" class="outline-3">
<h3 id="predicatelist">Known predicates &amp; options</h3>
<div class="outline-text-3" id="text-predicatelist">
<p>
The full list of options and predicates:
</p>

<div class="ctabs" id="orgfd61527">
<div class="rs" id="org61b6070">
<p>

</p>

<p>
Current set of <a href="../docs/rust/linkspace/query/enum.PredicateType.html">predicates</a> and 
<a href="../docs/rust/linkspace/query/enum.KnownOptions.html">options</a>.
</p>

<p>
Unknown options are added but ignored by most library functions.
This allows other processes to add additional options it understands.
</p>

</div>

<div class="sh" id="orgd513389">
<div class="org-src-container">
<pre class="src src-bash">lk print-query --help
</pre>
</div>

<pre class="example" id="orgb4351de">
hash         - the point hash e.g. \[b:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\]
group        - group id e.g. \[#:pub\]
domain       - domain - if fewer than 16 bytes, prepadded with  e.g. \[a:example\]
prefix       - all points with spacename starting with prefix - only accepts '=' op e.g. /hello/world
spacename    - exact spacename - only accepts '=' op e.g. /hello/world
pubkey       - public key used to sign point e.g. \[@:me:local\]
create       - the create stamp e.g. \[now:-1H\]
depth        - the total number of space components - max 8 e.g. \[u8:0\]
links_len    - the number of links in a packet e.g. \[u16:0\]
data_size    - the byte size of the data field e.g. \[u16:0\]
recv         - the recv time of a packet e.g. \[now:+1D\]
i_branch     - total packets per uniq (group,domain,space,key) - only applicable during local tree index, ignored otherwise e.g. \[u32:0\]
i_db         - total packets read from local instance e.g. \[u32:0\]
i_new        - total newly received packets e.g. \[u32:0\]
i            - total matched packets e.g. \[u32:0\]
hop          - (mutable) number of hops e.g. \[u16:5\]
stamp        - (mutable) variable stamp e.g. \[now\]
ubits0       - (mutable) user defined bits e.g. \[u32:0\]
ubits1       - (mutable) user defined bits e.g. \[u32:0\]
ubits2       - (mutable) user defined bits e.g. \[u32:0\]
ubits3       - (mutable) user defined bits e.g. \[u32:0\]
type         - the field type bits - implied by other predicates e.g. \[b2:00000001\]
netflags     - (mutable) netflags e.g. \[b2:00000000\]
size         - exact size of the netpkt when using lk_write or lk_read - includes netheader and hash  e.g. \[u16:4\]

The following options are available

	:mode
	:qid
	:follow
	:notify-close


query - print full query from common aliases

Usage: lk print-query [OPTIONS] [DGPD] [-- &lt;EXPRS&gt;...]

Arguments:
  [DGPD]      
  [EXPRS]...  

Options:
  -p, --print-expr               print the query
      --print-text               print in ascii-byte-text format (ABE without '[..]' expressions)
      --mode &lt;MODE&gt;              [default: tree-desc]
      --db-only                  only match locally indexed pkts           | i_new:=:[u32:0]
      --new-only                 only match new unindexed pkts             | i_db:=:[u32:0]
      --max &lt;MAX&gt;                match upto max packets.                   | i:&lt;:[u32:max]
      --max-branch &lt;MAX_BRANCH&gt;  match upto max per (dm,grp,space,key) pkts | i_branch:&lt;:[u32:max_branch]
      --max-index &lt;MAX_INDEX&gt;    match upto max from local index           | i_db:&lt;:[u32:max_index]
      --max-new &lt;MAX_NEW&gt;        match upto max unindexed pkts             | i_new:&lt;:[u32:max_new]
      --signed                   match only signed pkts                    | pubkey:&gt;:[@:none]
      --unsigned                 match only unsigned pkts                  | pubkey:=:[@:none]
      --watch                    Add :qid option (generates qid)
      --qid &lt;QID&gt;                set :qid option (implies --watch)
      --follow                   Add :follow option
      --until &lt;UNTIL&gt;            add recv:&lt;:[us:INIT:+{until}] where INIT is set at start
  -b, --bare                     do not read any domain:group:space argument - WARNING - this might include all datapoints depending on mode and filters
  -h, --help                     Print help

General Pkt IO Options:
      --private  enable io of linkpoints in [#:0] [env: LK_PRIVATE=]
</pre>

</div>

</div>
</div>
</div>

<div id="outline-container-lk_hash_query" class="outline-3">
<h3 id="lk_hash_query">lk_hash_query</h3>
<div class="outline-text-3" id="text-lk_hash_query">
<p>
[This function might be removed]
</p>

<p>
A shorthand for getting a packet by hash.
Can be used with <a href="#lk_watch">lk_watch</a>.
If you expect the value to be known locally <a href="#lk_get">lk_get_hash</a> is faster.
</p>
</div>
</div>
</div>



<div id="outline-container-runtime" class="outline-2">
<h2 id="runtime">Runtime</h2>
<div class="outline-text-2" id="text-runtime">
<p class="verse">
<a href="../docs/rust/linkspace/linkspace/index.html">Rust docs</a><br>
</p>

<p>
You can open/create a instance with <a href="#lk_open">lk_open</a>.
If given no directory it opens $LK_DIR or $HOME/linkspace.
</p>

<p>
An instance is a handle to a multi-reader, single-writer database. 
The instance is thread local. Each thread or process requires calling <a href="#lk_open">lk_open</a>.
</p>

<p>
An application can save to the database (<a href="#lk_save">lk_save</a>).
To read from the database you can directly get a packet by hash (<a href="#lk_get">lk_get_hash</a>) or using a query (<a href="#lk_get">lk_get</a>, <a href="#lk_get_all">lk_get_all</a>).
</p>

<p>
A thread can register a watch (<a href="#lk_watch">lk_watch</a>).
A watch is a query &amp; function that is called for each new packet matching the query.
By default the function is immediatly called for each match in the database.
</p>

<p>
Whenever any thread saves a new packet all other threads receive a signal.
</p>

<p>
By default nothing happens.
A thread does not see the new packets untill its read transaction is updated.
This includes calls to <code>lk_get*</code> and <code>lk_watch</code>.  
</p>

<p>
Update the transaction and process all the new packets (<a href="#lk_process">lk_process</a>,<a href="#lk_process_while">lk_process_while</a>).
This runs all functions registered as a watch.
Only after that is the thread's view of the database updated to the latest state.
</p>

<p>
The <a href="../docs/rust/linkspace/linkspace/index.html">Rust docs</a> are currently the most up to date, but the python package has most functions typed and commented as well.
</p>
</div>

<div id="outline-container-lk_open" class="outline-3">
<h3 id="lk_open">lk_open</h3>
<div class="outline-text-3" id="text-lk_open">
</div>
</div>


<div id="outline-container-lk_save" class="outline-3">
<h3 id="lk_save">lk_save</h3>
<div class="outline-text-3" id="text-lk_save">
</div>
</div>


<div id="outline-container-lk_get" class="outline-3">
<h3 id="lk_get">lk_get</h3>
<div class="outline-text-3" id="text-lk_get">
</div>
</div>

<div id="outline-container-lk_get_all" class="outline-3">
<h3 id="lk_get_all">lk_get_all</h3>
<div class="outline-text-3" id="text-lk_get_all">
</div>
</div>

<div id="outline-container-lk_get" class="outline-3">
<h3 id="lk_get">lk_get_hash</h3>
<div class="outline-text-3" id="text-lk_get">
</div>
</div>



<div id="outline-container-lk_watch" class="outline-3">
<h3 id="lk_watch">lk_watch</h3>
<div class="outline-text-3" id="text-lk_watch">
</div>
</div>


<div id="outline-container-lk_process" class="outline-3">
<h3 id="lk_process">lk_process</h3>
<div class="outline-text-3" id="text-lk_process">
</div>
</div>

<div id="outline-container-lk_process_while" class="outline-3">
<h3 id="lk_process_while">lk_process_while</h3>
<div class="outline-text-3" id="text-lk_process_while">
</div>
</div>


<div id="outline-container-lk_close_watch" class="outline-3">
<h3 id="lk_close_watch">lk_close_watch</h3>
<div class="outline-text-3" id="text-lk_close_watch">
</div>
</div>
</div>


<div id="outline-container-Conventions" class="outline-2">
<h2 id="Conventions">Conventions</h2>
<div class="outline-text-2" id="text-Conventions">
<p class="verse">
<a href="../docs/rust/linkspace/conventions/index.html">Rust docs</a><br>
</p>

<p>
Conventions are functions built on top of the other linkspace functions.
They provide a standard way for unrelated processes to loosly couple/interface with each other by encoding data into linkspace packets.
</p>

<p>
Generally they require the caller to also run <a href="#lk_process">lk_process</a> or <a href="#lk_process_while">lk_process_while</a>
</p>

<p>
One general conventions is that domains and spacenames starting with \xff are for meta things such as status queries and packet exchange.
</p>
</div>

<div id="outline-container-lk_status_set" class="outline-3">
<h3 id="lk_status_set">lk_status_set</h3>
<div class="outline-text-3" id="text-lk_status_set">
<p>
Status queries allow us to communicate if a process exists that is handling a specific type and a specific instance.
</p>

<p>
The function signature is (<code>domain</code>, <code>group</code>, <code>obj_type</code>, <code>instance</code>).
</p>

<ul class="org-ul">
<li>A request is a packet in the form DOMAIN:[#:0]:/\fstatus/GROUP/type(/instance?) and has no data and no links.</li>
<li>A reply is of the form DOMAIN:[#:0]/\status/GROUP/type/instance with some data and at least one link.</li>
</ul>

<p>
Note that the packets are in `#:0`.
This function is only for local status updates.
</p>

<p>
The group argument does not ask inside GROUP, it only signals which group the query is about.
Other processes are meant to answer a request.
</p>

<p>
The following are statuses that the exchange process should set:
</p>

<ul class="org-ul">
<li>exchange GROUP process</li>
<li>exchange GROUP connection PUBKEY</li>
<li>exchange GROUP pull PULL PULL_HASH</li>
</ul>
</div>
</div>

<div id="outline-container-lk_status_poll" class="outline-3">
<h3 id="lk_status_poll">lk_status_poll</h3>
<div class="outline-text-3" id="text-lk_status_poll">
<p>
Request the status of a `domain group obj_type ?instance timeout`.
</p>
</div>
</div>


<div id="outline-container-lk_pull" class="outline-3">
<h3 id="lk_pull">lk_pull</h3>
<div class="outline-text-3" id="text-lk_pull">
<p>
A pull request is made by a domain application and signals the set of packets it wants.
The function takes the query and saves it as: 
<code>[f:exchange]:[#:0]:/pull/[query.group]/[query.domain]/[query.qid]</code>
</p>

<p class="verse">
Note that from a domain's perspective, there is no such thing as 'fully synchronized'.<br>
It is entirely up to the developer to structure their points such that it provides the right level of sync.<br>
For example, a 'log' packets that link to known packets from a single device's perspective.<br>
</p>

<p>
Pull queries must have the predicates <code>domain:=:..</code> and <code>group:=:..</code>, and <code>:qid</code>.
</p>

<p>
An exchange process (such as in the <a href="../tutorial/index.html">tutorial</a>) watches these packets and attempts to gather them.
The exchange is only responsible for pull requests received when it is running.
The exchange drops requests when you reuse the 'qid'.
The function returns the hash of the request.
</p>

<p>
A domain application should be conservative with its query.
Requesting too much can add overhead.
</p>
</div>
</div>

<div id="outline-container-lk_key" class="outline-3">
<h3 id="lk_key">lk_key</h3>
<div class="outline-text-3" id="text-lk_key">
<p>
Read ( or creates ) an encrypted private key using the local LNS. It can then be referenced with <code>[@:NAME:local]</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-lns" class="outline-2">
<h2 id="lns">LNS</h2>
<div class="outline-text-2" id="text-lns">
<p>
See <a href="../../lns.html">LNS</a> for some general information.
See <a href="#ABELNS">abe#lns</a> for how to use LNS for lookup and reverse lookup.
</p>

<p>
The LNS system works by making a claim in <code>lns:[#:pub]:/claim/test/example/john</code> which we'll call <code>$Claim1</code>
A claim can have 3 types of special links.
The first link with the tag pubkey@ has as ptr the <code>pubkey</code> bytes to use when referring to <code>@:john:example:test</code>.
The first link with the tag group# has as ptr the <code>group</code> bytes to use when referring to <code>#:john:example:test</code>.
Every tag ending with '<code>^</code>' e.g. <code>root_00^</code> is an authority public key.
An authority has the right to vote for its direct subclaims. For example the claim <code>lns:[#:pub]:/claim/test/example/john/home/</code>
</p>

<p>
<code>$Claim1</code> becomes 'live' when a single authority of <code>claim/test/example</code> creates a vote by creating a keypoint <code>lns:[#:pub]:/claim/test/example/john</code> with
the link <code>vote:$Claim1.hash</code>. The first claim to get a majority of votes wins.
</p>
</div>
</div>

<div id="outline-container-orgb40058f" class="outline-2">
<h2 id="orgb40058f">Advanced topics</h2>
<div class="outline-text-2" id="text-orgb40058f">
</div>
<div id="outline-container-bigdata" class="outline-3">
<h3 id="bigdata">Big data</h3>
<div class="outline-text-3" id="text-bigdata">
<p>
One way of reading/writing data larger than aprx 2<sup>16</sup> is to create a linkpoint with multiple <code>("data",datap_hash)</code>.
That would give you space for <code>85mb</code>. You can go infinitely large by adding <code>("continue",next_linkpoint)</code>.
</p>

<div class="ctabs" id="org712615c">
<div class="sh" id="orgaba4172">
<p>

</p>

<div class="org-src-container">
<pre class="src src-bash">python -c 'print("-" * 200000000,end="")' \
    | lk data \
    | lk collect example:: --create [epoch] --collect-tag 'data' --chain-tag 'continue'\
    | lk save -f \
    | lk filter example:: \
    | lk pktf "[hash:str] [links_len:str]"
</pre>
</div>

<pre class="example" id="org0be300c">
JIhVzkxzP5kfPhjdudu0a6nDcbnOGKixsEvd4SXeoNc 1333
KxvjqFFRCRDFpzyNsXr80K3wMkBUD9Sszhfcjpt9qro 1334
1FAKPrMTY8nBQ4zeoXVvgn_ESQJcjJQ8l9fJDSmDEgA 411
</pre>

<p class="verse">
Advanced tip: we could have made this shorter with <code>collect --forward db --write db --write stdout-expr "[hash:str] [links_len]"</code><br>
</p>

</div>

</div>

<p>
Note that to recreate the data you have to do a 'depth first' search starting from the last result
</p>

<div class="ctabs" id="org5dd14b1">
<div class="sh" id="orgc42c70c">
<p>

</p>

<div class="org-src-container">
<pre class="src src-bash">lk watch-hash 1FAKPrMTY8nBQ4zeoXVvgn_ESQJcjJQ8l9fJDSmDEgA | lk get-links -R pause | lk pktf -d '' [data] &gt; /tmp/bytes
python -c 'print("-"*200000000,end="")' &gt; /tmp/bytes2
diff /tmp/bytes /tmp/bytes2 &amp;&amp; echo ok
</pre>
</div>

<pre class="example" id="org42f1494">
ok
</pre>


<p class="verse">
Note the pktf -d '' to remove the delimiter between packets.<br>
An alternative approach would be to use <code>lk get-links --write file-expr:[/:/tmp/bytes]:[data] --forward null</code><br>
</p>

</div>

</div>
</div>
</div>
</div>



<div id="outline-container-qa" class="outline-2">
<h2 id="qa">Q&amp;A</h2>
<div class="outline-text-2" id="text-qa">
</div>


<div id="outline-container-org939469c" class="outline-5">
<h5 id="org939469c">Why Big Endian?</h5>
<div class="outline-text-5" id="text-org939469c">
<p>
The tree index is in the expected order when using the numbers as space components.
E.g. <code>lk linkpoint ::/some/dir/[now]</code> will come after <code>lk linkpoint ::/some/dir/[now:-1D]</code> because <code>now &gt; (now - one day)</code>
</p>
</div>
</div>

<div id="outline-container-org92dc42c" class="outline-5">
<h5 id="org92dc42c">Every user of my domain app needs X from my server/I want to add advertisements to my domain app.</h5>
<div class="outline-text-5" id="text-org92dc42c">
<p>
Hardcode a public key into the app and combine it with a group exchange service.
Either use an existing group, or use the group: their-key XOR your-key for personalized stuff
</p>
</div>
</div>

<div id="outline-container-orgbf6d952" class="outline-5">
<h5 id="orgbf6d952">I'm not in control of the user! / Anybody in my group can leak data from it!?</h5>
<div class="outline-text-5" id="text-orgbf6d952">
<p>
If this is news to you, you're suffering from security-theater.
I don't make the rules, I just make them obvious.
</p>
</div>
</div>

<div id="outline-container-orgabb173b" class="outline-5">
<h5 id="orgabb173b">A domain application can write outside its own domain space.</h5>
<div class="outline-text-5" id="text-orgabb173b">
<p>
Yes, the current API has no restriction.
Maybe at some point we can effectively restrict processes through wasm or some other access control.
</p>
</div>
</div>

<div id="outline-container-org0d3ca55" class="outline-5">
<h5 id="org0d3ca55">Why don't queries support negative predicates?</h5>
<div class="outline-text-5" id="text-org0d3ca55">
<p>
In most cases the meaning would be non obvious and/or slow to implement, and it would remove their "string concat == union" property.
</p>

<p>
Furthermore, when you want to exclude something it is much clearer to always have to define two phases.
i.e. All packets in group X, excluding those with property Y.
</p>
</div>
</div>

<div id="outline-container-org8ec91af" class="outline-5">
<h5 id="org8ec91af">Why not use an SQL backend? / Why create Queries?</h5>
<div class="outline-text-5" id="text-org8ec91af">
<p>
First off, if you're asking because you want to do SQL queries its not too difficult to stream packets into a SQL table with `lk pktf` or some custom code, and query them.
</p>

<p>
Why its not the primary backend/query method has multiple reason. 
</p>

<p>
SQL isn't magic, and its non-trivial price to pay for something that is not a great fit for a few fundamental problems including:
</p>

<ol class="org-ol">
<li>What are the tables peers should have?</li>
<li>How to constrain a query you receive/as it travels to multiple peers?</li>
<li>how to encode bytes?</li>
</ol>

<p>
All could be solved in a number of ways, but most solutions are quickly going to bloat and usually create multiple incompatible sublanguages
depending on the context.
</p>

<p>
linkspace queries support arbitrary bytes, can be constraint/tested through concatenation, and have a consistent meaning w.r.t. predicates and can easily be expanded with options.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">the hash of <code>lk_datapoint(b"Hello, Sol!\n")</code></p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Created: 2023-10-02 Mon 16:49</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>