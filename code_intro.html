<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-01-18 Thu 15:17 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Quick start</title>
<meta name="author" content="R.A. Sol" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">Quick start</h1>
</header><p>
This introduction uses the `lk` cli with bash.
You can follow along by <a href="https://github.com/AntonSol919/linkspace/releases">downloading</a> the latest release. 
If you're more comfortable with Python or want a more detailed explanation check out the guide.  
</p>

<div class="org-src-container">
<pre class="src src-bash" id="orgd153e58">lk --version
</pre>
</div>

<pre class="example" id="org7248406">
linkspace-cli linkspace-cli - 0.6.0 - main - cf010d4 - 1.77.0-nightly
</pre>

<div id="outline-container-org5e7aff0" class="outline-2">
<h2 id="org5e7aff0"><span class="section-number-2">1.</span> Point</h2>
<div class="outline-text-2" id="text-1">
<p>
A single unit|event|message in linkspace is called a `point`.
A point can hold just shy of 64kb.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="orga73db08">echo "Hello, Sol!" | lk point &gt; mylog
</pre>
</div>

<p>
Points have a few of optional properties besides the data field.
</p>

<p>
a spacename:
</p>
<div class="org-src-container">
<pre class="src src-bash" id="orgaeb9ee5">echo -n some data | lk point ::/my/example/spacename --data-stdin &gt;&gt; mylog
</pre>
</div>

<p>
a timestamp in microseconds since epoch using `now` by default:
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org35f2cb0"># 12 seconds in the past - we'll get back to the [..] syntax 
lk point ::/my/example/other_space --stamp [now:-12s] &gt;&gt; mylog 
</pre>
</div>

<p>
and a signature:
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org08fdaeb">KEY=$(lk key --no-pubkey --no-lk --password 'my secret') 
lk point ::/my/example/spacename/subspace --sign --enckey "$KEY" --password 'my secret' &gt;&gt; mylog
</pre>
</div>
<p>
All points are hashed using Blake3. 
</p>

<p>
<b>Point's refer to the hashed fields/data. The point, hash, and a header are packed into the packet format. Functions/APIs deal exclusively in the packet format.</b>
</p>

<p>
`pktf` formats a stream of packets.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="orgad26da5">cat mylog | lk pktf "Hash: [hash:str] is a point at '[space:str]' with data '[data]'"
</pre>
</div>

<pre class="example" id="org27d4d51">
Hash: Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk is a point at '' with data 'Hello, Sol!
'
Hash: wnX2wponxVQ_u6fml6m9kebtVDIIKx0OgA28EG5o8GE is a point at '/my/example/spacename' with data 'some data'
Hash: F1AdaT0fg-uQsgGJIQBJlO5SWhopCdKW8yy6qorP1uo is a point at '/my/example/other_space' with data ''
Hash: iEsYVyzzqY544sJLUpwJq7-VeK2WJH1V8rjoWiT__zY is a point at '/my/example/spacename/subspace' with data ''
</pre>

<p>
Or output only data: `cat mylog | lk pktf "[data]"`.
</p>

<p>
The other fields are readable by general purpose tools to index, address, and filter the packets. 
For example, lk filter.
Here we only take those with a spacename starting with `/my/example` and 1 additional component
</p>

<div class="org-src-container">
<pre class="src src-bash" id="orge02dc3e">cat mylog | lk filter ::/my/example:* | lk pktf "[hash:str] [space:str]"
</pre>
</div>

<pre class="example" id="org72abb09">
wnX2wponxVQ_u6fml6m9kebtVDIIKx0OgA28EG5o8GE /my/example/spacename
F1AdaT0fg-uQsgGJIQBJlO5SWhopCdKW8yy6qorP1uo /my/example/other_space
</pre>

<p class="verse">
You can go build even more complex filters with `lk do -s &#x2013;write stdout &#x2013; [..]`<br>
</p>

<p>
Points are addressable by their hash.
To reference one point from another you add a link. 
Each link is a 16 byte tag and 32 byte hash value.
If less than 16 bytes are supplied it is left-padded with 0's.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org327b1b0">HASH=($(cat mylog | lk pktf [hash:str]))
lk point "::/my/example/link" -- "my first link:${HASH[0]}" "other link:Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk" &gt;&gt; mylog
</pre>
</div>

<p>
You can get fancy with `pktf` and `xargs`.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org80808ee">cat mylog | lk pktf "mytag:[hash:str]" | xargs lk point ::/my/example/link -- &gt;&gt; mylog
</pre>
</div>

<p class="verse">
When building a log you should start with only using the data field, in a readable format like JSON.<br>
Only when required should you expand to use the more advanced features like spacenames, signatures, and links.<br>
<br>
You can ask if cryptographic properties, like signatures or distributed event ordering by linking, are worth to add upfront if you want to focus on the data.<br>
The answer is yes.<br>
Cryptographic signatures and hash addresses are difficult to get right, and infeasible to add retroactively.<br>
</p>

<p>
A tool like `lk collect` has a few additional options for building points linking to other points.
However, the `lk` binary is meant to do simple things.
Use the library and a better programming language when doing non-trivial stuff.
</p>

<div class="HTML" id="org44b8504">
<p>
&lt;details&gt;
&lt;summary&gt;
Click here to see a graphical representation of mylog
&lt;/summary&gt;
</p>

</div>


<figure id="org99dfd42">
<img src="images/mylog-dot.svg" alt="mylog-dot.svg" class="org-svg">

</figure>


<div class="HTML" id="org3401f9c">
<p>
&lt;/details&gt;
</p>

</div>

<p>
Creating packets with `lk point` detects what kind you're trying to build.
But it is better to be explicit. The 3 types of points are:
`datapoint`, `linkpoint`, or `keypoint` (a signed linkpoint).
</p>

<p>
NOTE: linkpoint and keypoint do not read data from stdin by default.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="orgb304c44">echo somedata | lk linkpoint ::/my/other_spacename --data-stdin | lk pktf "[hash:str] = [data]"
</pre>
</div>

<pre class="example" id="orgf12f39d">
wps6Wsg6aToFSbMKmD3BfXjIefZag4fF8JWaXIXAjjs = somedata
</pre>
</div>
</div>


<div id="outline-container-org8bd6d20" class="outline-2">
<h2 id="org8bd6d20"><span class="section-number-2">2.</span> Database</h2>
<div class="outline-text-2" id="text-2">
<p>
Linkspace is primarily its packet format.
Using the database is optional.
</p>

<p>
The database and other tools exists to make it easier to build complex systems and packet flows.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="orgf75e8fa">export LK_DIR=/tmp/linkspace ; 
lk init ; 
cat mylog | lk write &gt; /dev/null ; 
</pre>
</div>

<pre class="example" id="org1261f6f">
LkInfo { kind: "lmdb", dir: None }
</pre>

<p>
Instead of using `save` you can set a write destinations directly.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org9f03aa5">echo hello world | lk point --write db --write file:mylog --write stdout | lk pktf [data]
</pre>
</div>

<pre class="example" id="org2a9c6ea">
hello world
</pre>

<p>
The database has three indices. 
A 'log', 'hash', and the 'tree' index. 
The log-index is ordered by receive order, the hash-index by the point hash, and the tree-index primarily by a point's [space, create stamp] (see the guide for full details).
</p>

<p>
The database is always accessed through the runtime. 
The runtime lets multiple processes/threads can read, write, and watch for new points.
</p>

<p>
The library API uses callbacks and a user-driven eventloop (<a href="./guide/index.html#runtime">guide</a>).
`lk` is focused on piping packets.
Commands are `watch-log`, `watch-tree`, `watch-hash`. These are shorthand for  `watch &#x2013;mode ..`.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org75bfddc">lk watch-tree ::/my:** | lk pktf "[space:str]" &gt; ./watching &amp;
</pre>
</div>

<pre class="example" id="org19c1737">
[1] 868
</pre>

<div class="org-src-container">
<pre class="src src-bash" id="org665c798">cat ./watching
</pre>
</div>

<pre class="example" id="org2a7130a">
/my/example/link
/my/example/link
/my/example/spacename
/my/example/other_space
/my/example/spacename/subspace
</pre>

<p>
Adding a new point
</p>

<div class="org-src-container">
<pre class="src src-bash" id="orgfc8731c">lk linkpoint ::/my/my/my --write db
</pre>
</div>

<p>
Wakes the watching threads to output the new point.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org32bdc84">cat ./watching
</pre>
</div>

<pre class="example" id="org3f86552">
/my/example/link
/my/example/link
/my/example/spacename
/my/example/other_space
/my/example/spacename/subspace
/my/my/my
</pre>
</div>
</div>

<div id="outline-container-orgf6475ab" class="outline-2">
<h2 id="orgf6475ab"><span class="section-number-2">3.</span> Applications</h2>
<div class="outline-text-2" id="text-3">
<p>
There are two optional fields included in the hash not yet shown. 
The domain and group.
</p>

<p>
The domain is analogous to a IP port. 
An application pick a domain name (max 16 bytes).
For example `imageboard`.
</p>

<p class="verse">
`pktf` is common enough to have the alias `lk p`.<br>
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org5c8b59b">lk linkpoint imageboard:: | lk p "[domain:str]"
</pre>
</div>

<pre class="example" id="orgfcddaf3">
imageboard
</pre>

<p>
Groups indicate the set of intended recipients.
If a group exchange process is running, an application doesn't have to deal with sockets, (HTTP) endpoints, or other IO except for the user interface.
The application can read, write, request from the group, and process packets using just the linkspace library. 
</p>

<p>
Building an application is done by mapping an application state to and from linkspace packets (in the database).
For example, a drawing application where multiple people can paint to a shared image board.
A simple mapping could be: 
</p>

<ul class="org-ul">
<li>Images data are saved as data points</li>
<li>Every link in a linkpoint is: a hash to an image, and a tag holding (x,y) coordinates.</li>
</ul>

<p>
Adding an image might look something like: 
</p>

<div class="org-src-container">
<pre class="src src-bash" id="orgce2289f">X=30 ; Y=200 ; IMG="https://upload.wikimedia.org/wikipedia/commons/3/35/Tux.svg" ; 
curl -s $IMG | lk datapoint &gt; tux.pkt
IMG_HASH=$(cat tux.pkt | lk p "[hash:str]")
lk linkpoint imageboard:: -- $(printf "%08d%08d" "$X" "$Y"):$IMG_HASH &gt;&gt; tux.pkt
lk write --pkts ./tux.pkt # Instead of `cat` we can provide a file
</pre>
</div>

<p>
Building an image requires the program to watch for new packets in `imageboard::`, and on every (new) point draw over the image.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org93adbc9">lk watch-tree "imageboard::" --max 1 \
   | lk p "[hash:str] has the links:\n [links]" 
</pre>
</div>

<pre class="example" id="orgf2163f1">
zDquQvNuDXOcIGLy3YND3sN0s8qZA5DH3uYOpJtl3AY has the links:
 0000003000000200:Sz0ZZDWxKht-jbM7Tfkn0nis4tNoKNPH_kfI7JYUnY4
</pre>

<p class="verse">
You should always quote your arguments.<br>
Otherwise, the previous example would not have worked.<br>
Without the quotes the characters `[lin` in "[links]" would be interpreted by the default bash shell.<br>
</p>

<p>
A link might reference a point that is not (yet) available on the device.
An application has to decide how to handle the situation.
In this example we'll just wait. 
Waiting can be done manually. e.g.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org44f275a">lk watch-tree "imageboard::" --max 1 \
   | lk p "[links]" \
   | cut -d':' -f2 \
   | xargs -i lk watch-hash "{}" \
   | lk pktf "got point [hash:str] which has [data_size:str] bytes"
</pre>
</div>

<pre class="example" id="org7c687f2">
got point Sz0ZZDWxKht-jbM7Tfkn0nis4tNoKNPH_kfI7JYUnY4 which has 49983 bytes
</pre>

<p>
Or use `lk get-links`. It has a few common strategies.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="orge311736">lk watch-tree "imageboard::" --max 1 \
    | lk get-links pause \
    | lk pktf "[hash:str]"
</pre>
</div>

<pre class="example" id="org368ccdc">
Sz0ZZDWxKht-jbM7Tfkn0nis4tNoKNPH_kfI7JYUnY4
zDquQvNuDXOcIGLy3YND3sN0s8qZA5DH3uYOpJtl3AY
</pre>

<p>
To complete the imageboard application we'll have to add a few more steps to merge the data into a single picture.
See the tutorial for an example on doing this and more. 
</p>

<p>
The final piece of the puzzle is the group field. 
A group is 32 bytes to signal the intended set of recipients. 
It is orthogonal to the domain field, as the application should not care which group its running in.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org1f9aa6c">PUB=$(echo "Hello, Sol!" | lk data | lk pktf "[hash:str]")
lk linkpoint :$PUB:/example | lk p "[group:str]"
</pre>
</div>

<pre class="example" id="org5d3d5cc">
Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk
</pre>

<p>
If no group is specified (like we've been doing) the public group is used.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org374915d">lk linkpoint :[#:pub]:/example  | lk p "[group:str]" 
</pre>
</div>

<pre class="example" id="orgdf6dc66">
Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk
</pre>

<p class="verse">
See <a href="./guide/index.html#ABE">ABE</a> for more on the `[..]` syntax.<br>
Its a small byte templating language included in the library for convenience with the syntax being the same for all programming language.<br>
ABE is also heavily used for CLI arguments, e.g. `lk linkpoint :: &#x2013;stamp [now]` or `[now:+2h]`<br>
</p>

<p>
The other special group is `[0;32]`, also called the private group.
You can refer to it with the expression `[#:0]`.
Functions/subcommands that read/write existing points skip and/or warn whenever a point from the private group is seen unless enabled with `&#x2013;private`.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org58d0dea">lk linkpoint domain:[#:0] | lk write 2&gt;&amp;1 # creating a packet is ok - but receving is not accepted by `lk write` without --private
</pre>
</div>

<pre class="example" id="org9e54767">
error: Args { inner: ["/home/rs/Projects/linkspace/target/debug/lk", "write"] }
Pkt(
    PrivateGroup,
)
</pre>

<p>
A system to exchange points in a group can be made from scratch.
Linkspace does not prescribe a way to do so.
Each group / network is different, and no single solution can cover every situation.
</p>

<p>
For example, use `lk watch imageboard:$MYGROUP | &#x2026;` and forward the entire stream to another device using netcat/socat, ssh, email, http, a USB stick,
or other way to exchange bytes. 
</p>

<p>
Linkspace is designed to only ever be a streams of packets,
without additional overhead of a (custom) serialization formats. 
As evident by the 'mylog' file we have used thus far.
This keeps streams compatible with all tools that process streams.
</p>

<p>
To that end, each packet has a mutable header excluded from the hash. 
</p>

<p>
Filters work on these mutable bytes as well.
This let you quickly build specific network topologies.
</p>

<p class="verse">
See <a href="./guide/index.html#mutable">the guide</a> for the mutable field names.<br>
</p>

<pre class="example" id="orgcc78b2e">
netcat 10.0.0.1 -p 6000 | lk route ubits0:=:0000 | lk write &amp; # get packets from a host and set their ubits0 to 0000
netcat 10.0.2.0 -p 6000 | lk route ubits0:=:0001 | lk write &amp; # get packets from another host and set their ubits0 to 0001
lk linkpoint example::/hello | lk route ubits0:=:0002 | lk write # write my packets with ubits 0002
lk watch-log --asc example::/hello -- "ubits0:&gt;:0000" | nc 10.0.0.1 -p 6000  &amp; # forward all packets with ubits0 higher than 0000 back to host. 
</pre>

<p>
A single linkspace instance can be used by multiple applications on device, and connect to others.
To that end there are some conventions.
These are functions that create/watch for point with some predefined spacename, links, and data format.
Conventions enable interoperability between multiple applications and background processes.
</p>

<p>
One such convention is the `pull` convention. This writes a query as a specific point.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org3f71db6">lk pull imageboard:: --write stdout | lk p "[space:str]\n\n[data]"
</pre>
</div>

<pre class="example" id="org65e2762">
/pull/[b:Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk]/[a:imageboard]/default

:qid:default
type:1:[b2:00000010]
domain:=:[a:imageboard]
group:=:[b:Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk]
depth:=:[u8:0]
</pre>

<p>
The goal of `pull` is to allow one process, e.g. an application like <a href="./tutorial/imageboard.html">imageboard (bash)</a> or <a href="./tutorial/mineweeper-1.html">mineweeper (python)</a>
to signal another process, e.g. a group exchange process like  <a href="./tutorial/bash.exchange.html">bash.exchange</a>,
that it wants packets matching a query from the group.
</p>

<p>
Queries define a 'set of points' in linkspace.
The `filter` and `watch` commands are syntax sugar over queries.
You can add `&#x2013;print-query` to those commands to see the query used.
</p>

<p>
Queries are designed such that joining two query strings the result is the common subset of both or an error if the union is empty.
</p>

<div class="org-src-container">
<pre class="src src-bash" id="org8bb99bb">lk print-query example::/ok 
</pre>
</div>

<pre class="example" id="org58a044b">
:mode:tree-desc

type:1:[b2:00000010]
domain:=:[a:example]
group:=:[b:Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk]
prefix:=:/ok
depth:=:[u8:1]
</pre>

<div class="org-src-container">
<pre class="src src-bash" id="orgbdbbece">lk print-query example::/ok -- "spacename:=:/not_ok"
</pre>
</div>

<pre class="example" id="org52a275a">
error: Args { inner: ["/home/rs/Projects/linkspace/target/debug/lk", "print-query", "example::/ok", "--", "spacename:=:/not_ok"] }
Error {
    context: "could not turn stmt into valid extpred",
    source: ParseKind(
        spacename,
    ),
}
</pre>

<p>
That's it for this quick introduction.
Some notes on high level algorithm <a href="https://www.linkspace.dev/tutorial/application-design.html">design</a> are worth a read.  
For a more in-depth technical guide or the library API see the <a href="./guide/index.html">Guide</a>.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: R.A. Sol</p>
<p class="date">Created: 2024-01-18 Thu 15:17</p>
</div>
</body>
</html>