#+TITLE: Quick start
#+PANDOC_OPTIONS: template:./template.pml 
#+OPTIONS: toc:nil

This introduction uses the `lk` cli with bash.
Follow along by [[https://github.com/AntonSol919/linkspace/releases][downloading]] the latest release. 

#+NAME: init
#+BEGIN_SRC bash :session codeorg :exports none
  cd /tmp/
  export LK_DIR=/tmp/linkspace
  rm -r linkspace
#+END_SRC

#+NAME: version
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  lk --version
#+END_SRC

*** Point

A single unit|event|message in linkspace is called a `point`. Each can hold ~64kb.

#+NAME: point-hello
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  echo "Hello, Sol!" | lk point > mylog
#+END_SRC

Points have optional properties besides the data field.

a spacename:
#+NAME: point-spacename
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  echo -n some data | lk point /my/example/spacename --data-stdin >> mylog
#+END_SRC

a timestamp in microseconds since epoch using `now` by default:

#+NAME: point-create
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  # 12minuites and 10 seconds in the past - the [..] syntax is touched on later
  lk point /my/example/other_space --stamp [now:-12m10s] >> mylog 
#+END_SRC

and a public key + signature:

#+NAME: point-signed
#+BEGIN_SRC bash :exports code
  KEY=$(lk key --no-pubkey --no-lk --password 'my secret') 
  lk point /my/example/spacename/subspace --sign --enckey "$KEY" --password 'my secret' >> mylog
#+END_SRC
#+NAME: real-signed
#+BEGIN_SRC bash :session codeorg :exports none :results output verbatim
# By default the key is made expensive te decrypt
  KEY='$argon2d$v=19$m=8,t=1,p=1$tb0anwpH0rSbYe6JLd1Bgtf00QQUAYuhOcBqeSjAgW4$kYAtGyF78cfPjRqcm4Y/s1hgQTRysELK/L910P2u27c'
  lk point /my/example/spacename/subspace --sign --enckey "$KEY" --password '' >> mylog
#+END_SRC

All points are hashed using Blake3. 

*Point's refer to the hashed fields/data. The point, hash, and a header are packed into the packet format. Functions/APIs deal exclusively in the packet format.*

`pktf` formats a stream of packets.

#+NAME: pktf
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  cat mylog | lk pktf "'[data]' hashes to: [hash:str]"
#+END_SRC

The format string evaluates and substitutes '[..]' expressions.
eg. output only data: `cat mylog | lk pktf "[data]"`.

The limited set of fields with their fixed wire format makes them fast to process.
For example using `lk filter`.

This command only passes those with a spacename starting with `/my/example` and 1 additional space component

#+NAME: filter
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  cat mylog | lk filter /my/example:* | lk pktf "[hash:str] [space:str]"
#+END_SRC

#+BEGIN_VERSE
Advanced tip: Build even more complex filters by using `lk do`
#+END_VERSE

Points are addressable by their hash.
To reference one point from another add a link.
Each link is a 16 byte tag and 32 byte hash.
If fewer than 16 bytes are used in the tag it is left-padded with 0's.

#+NAME: links
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  HASH=($(cat mylog | lk pktf [hash:str]))
  lk point "/my/example/linkpoing" -- "my first link:${HASH[0]}" "other link:Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk" >> mylog
#+END_SRC

Optionally get fancy with `pktf` and `xargs`.

#+NAME: links-xargs
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  cat mylog | lk pktf "mytag:[hash:str]" | xargs lk point /my/example/link -- >> mylog
#+END_SRC

A tool like `lk collect` has a few additional options for linking points received on stdin.
However, the `lk` cli has its limits.
Consider using a better programming language when doing non-trivial stuff.

#+BEGIN_HTML
<details>
<summary>
Click here to see a dot graphiv representation of `mylog`
</summary>
#+END_HTML

#+name: make-dot
#+BEGIN_SRC bash :session codeorg :exports none :results output verbatim :cache yes
lk p --pkts ./mylog '"p[hash:str]"\[label=" { <hash> [hash/2mini] }  | { signed: [pubkey/2mini] | [space:str] } | data=[data] | [links_len:str] links [/links: | <[i:str]> [tag:str]\: [ptr/2mini] ] "\];
     [/links: "p[hash:str]"\:[i:str] -> "p[ptr:str]"\:hash ;\n ]' ;
#+END_SRC

#+NAME: graph-mylog
#+BEGIN_SRC dot :file images/mylog-dot.svg :var input=make-dot :exports results :cache yes
  digraph G{
  rankdir=RL ;
  node[shape="record"] ;
   $input
 }
#+END_SRC


#+BEGIN_HTML
</details>
#+END_HTML

Creating packets with `lk point` detects what type of packet is being created.
However, it is better to be explicit. The 3 types of points are:
`datapoint`, `linkpoint`, or `keypoint` (a signed linkpoint).

For the linkpoint and keypoint command, data is not read from stdin by default.

#+NAME: point-stdin
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  echo somedata | lk linkpoint /my/other_spacename --data-stdin | lk pktf "[hash:str] = [data]"
#+END_SRC


*** Database

Up to this point packets were simply dumped to a file.
Linkspace is primarily its packet format.
It can be used with plain files or any database.
However, library also includes a database.

#+NAME: db-init
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  export LK_DIR=/tmp/linkspace ; 
  lk init ; 
  cat mylog | lk write > /dev/null ; 
#+END_SRC

Instead of piping into `lk write`, most commands take a write destinations such as 'db'.

#+NAME: write
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  echo hello world | lk point --write db --write file:mylog --write stdout | lk pktf [data]
#+END_SRC

The database has three indices.

- 'log' is indexed on the timestamp a point is written to the database.
- 'hash' is indexed on the point's hash.
- 'tree' is essentially indexed on a point's [space, create stamp] (see the guide for full details).

The database is accessed through the runtime.
The runtime is notified whenever ANY process or thread saves to the database.
Using the library this requires registering callbacks that are triggered by a user-driven eventloop ([[./guide/index.html#runtime][guide]]).

The `lk` cli is focused on piping packets and handles most of the runtime.

Getting points from the runtime uses functions: `read`, `watch`, and `tap`.
`read` accesses the current database, `watch` reacts when new packet are written, and `tap` combines read and watch.

#+NAME: watchtree
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  lk tap-tree /my:** | lk pktf "[space:str]" > ./watching &
#+END_SRC
#+BEGIN_SRC bash :session codeorg :exports none
  sleep 1
#+END_SRC
#+NAME: react
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  cat ./watching
#+END_SRC

The current packets are read from disk and piped to a file.
When a (new) matching point is written to the database `lk tap-tree` is notified and writes it out.

#+NAME: watch-write
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  lk linkpoint /my/my/my --write db
#+END_SRC
#+BEGIN_SRC bash :session codeorg :exports none
  sleep 1
#+END_SRC

#+NAME: react2
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  cat ./watching
#+END_SRC

#+BEGIN_SRC bash :session codeorg :exports none
  kill %%
  sleep 1
#+END_SRC


*** Applications

Linkspace is designed for people to build distributed applications.
Software that can function independent of any middleman.

There are two fields not yet shown: domain and group.

The domain is analogous to a IP port.
An application pick a domain name (max 16 bytes).
For example `imageboard`.

#+BEGIN_VERSE
`pktf` is common enough to have the alias `lk p`.
#+END_VERSE

The cli syntax is `domain:group:/space`.
If one is left out or empty the default is the null domain and the public group. 

#+NAME: domain
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  lk linkpoint imageboard::/spacename | lk p "[domain:str]"
#+END_SRC

Building an application is essentially defining a mapping from a UI state to-and-from linkspace points.

#+BEGIN_VERSE
This type of application design requires a different way of thinking.

In network systems people are familiar with, a single authority holds the database and everyone is dependent on the order that authority defines.
This is the 'special' case of networked applications.
Most people see the digital space through the assumptions and limitations of this special case.
This has enormous (social) implications.

In the 'general' case of network applications, an order is defined with: hashes, links, and signatures.
This allows for many interesting designs, and it provides a better abstraction for a physical reality (e.g. CAP, the speed of light).

It is straightforward to emulate a classic app by having a single public key sign packets for clients to follow, thus creating a total order.
#+END_VERSE

As an example application consider a drawing application where multiple people paint to a single image without using a server.
A mapping could look like:

- Image data is saved in data points
- Every link in a linkpoint is: a hash to an image, and a tag holding (x,y) coordinates.

By choice we'll deal with the distributed challenges as follows to keep things simple:

    We don't care about missing data, and we'll trust people to set an approximately right timestamp.
    Every time we receive an update (even if newer updates were already added) we'll re-paint over our current picture by painting everything since that timestamp.

Adding an image might look something like: 

#+NAME: tuxpng
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  X=30 ; Y=200 ; IMG="https://upload.wikimedia.org/wikipedia/commons/3/35/Tux.svg" ; 
  curl -s $IMG | lk datapoint > tux.pkt
  IMG_HASH=$(cat tux.pkt | lk p "[hash:str]")
  lk linkpoint imageboard:: -- $(printf "%08d%08d" "$X" "$Y"):$IMG_HASH >> tux.pkt
  lk write --pkts ./tux.pkt # Instead of `cat tux.pkt |` reading directly from a pkts file
#+END_SRC

Building an image requires the program to tap points in `imageboard::` and for each result over a image.

#+name: watch-tree
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
 lk tap-tree "imageboard::" --max 1 \
    | lk p "[hash:str] has the links:\n [links]" 
#+END_SRC

#+BEGIN_VERSE
Always quote shell arguments.
Otherwise, the previous example would not have worked.
Without the quotes the characters `[lin` in "[links]" would be interpreted by the default bash shell.
#+END_VERSE

A link might hold a point's hash that is not (yet) in the database.
An application has to decide how to handle the situation.
In this example we'll just wait.
Waiting can be done manually. e.g.

#+name: watch-tree-links
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
 lk watch-tree "imageboard::" --max 1 \
    | lk p "[links]" \
    | cut -d':' -f2 \
    | xargs -i lk watch-hash "{}" \
    | lk pktf "got point [hash:str] which has [data_size:str] bytes"
#+END_SRC

Or use `lk get-links`. It has a few common strategies.

#+name: get-links
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
      lk watch-tree "imageboard::" --max 1 \
          | lk get-links pause \
          | lk pktf "[hash:str]"
#+END_SRC

To complete the imageboard application we'll have to add a few more steps to merge the data into a single picture.
See the tutorial for an example on doing this and more.

The final piece of the puzzle is the group field.
A group is 32 bytes to signal the intended set of recipients.
It is orthogonal to the domain field.
Well designed applications should not care what group is addressed.

#+name: group
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  PUB=$(echo "Hello, Sol!" | lk data | lk pktf "[hash:str]")
  lk linkpoint :$PUB:/example | lk p "[group:str]"
#+END_SRC

If no group is specified (either in an argument or $LK_GROUP environment variable) the public group is used.

#+name: group-str
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  lk linkpoint :[#:pub]:/example  | lk p "[group:str]" 
#+END_SRC

'creating' a group is as simple as picking 32 bytes, deciding who the members are, and ensuring they can exchange data.

#+BEGIN_VERSE
See [[./guide/index.html#ABE][ABE]] for more on the `[..]` syntax.
Its a tiny byte-templating language included in the library for convenience.
ABE is also heavily used for CLI arguments, e.g. `lk linkpoint :: --stamp [now]` or `[now:+2h]`
#+END_VERSE

The other special group is `[0;32]`, also called the private group.
It's usually referenced with the expression `[#:0]`.
Functions/subcommands that read/write existing points skip and/or warn whenever a point from the private group is seen unless enabled with `--private`.

#+name: private
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  lk linkpoint domain:[#:0] | lk write 2>&1 # creating a packet is ok - but receving is not accepted by `lk write` without --private
#+END_SRC

A network to exchange points in a group can be made from scratch.
Linkspace does not prescribe a way to do so.
Each group / network is different, and no single solution can cover every situation.

An example for a network is to use `lk watch imageboard:$MYGROUP | ...` and forward the entire stream to another device using netcat/socat, ssh, email, http, a USB stick,
or other way to exchange bytes.

Linkspace is designed to always be a streams of packets.
This keeps streams compatible with all tools that process streams.

However, sometimes packets should hold additional context information as they're shared around.
For that, each packet has a mutable header excluded from the hash.

Filters also work on these fields.
With this its possible to build for specific network topologies.

#+BEGIN_VERSE
See [[./guide/index.html#mutable][the guide]] for the mutable field names.
#+END_VERSE

#+name: exchange
#+BEGIN_SRC
  netcat 10.0.0.1 -p 6000 | lk route ubits0:=:0000 | lk write & # get packets from a host and set their ubits0 to 0000
  netcat 10.0.2.0 -p 6000 | lk route ubits0:=:0001 | lk write & # get packets from another host and set their ubits0 to 0001
  lk linkpoint example::/hello | lk route ubits0:=:0002 | lk write # write my packets with ubits 0002
  lk watch-log --asc example::/hello -- "ubits0:>:0000" | nc 10.0.0.1 -p 6000  & # forward all packets with ubits0 higher than 0000 back to host. 
#+END_SRC

A database is shared between multiple applications on a single device.
This allows some level of interprocess communications.

Somethings are common enough that the library includes functions called 'conventions'.
These create or watch for points with some predefined spacename, links, and data format.

One such convention is the `pull` convention.
An application creating a pull point signals that it wants a set of packets retrieved from others if possible.

#+name: pull
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  lk pull imageboard:: --write stdout | lk p "[space:str]\n\n[data]"
#+END_SRC

Pull creates a point containing a query.
Queries define a 'set of points' in linkspace and are used in many places.

This can be seen in action in an application like [[./tutorial/imageboard.html][imageboard (bash)]] or [[./tutorial/mineweeper-1.html][mineweeper (python)]] as they pull
and an exchange process like [[./tutorial/bash.exchange.html][anyhost.exchange]] server/client ensures that set of packets is retrieved.

The query is a structure used throught linkspace.
The command line arguments for `lk filter`, `lk watch`, etc are syntax sugar over queries.
Add `--print-query` to those commands to see the effective query.

Queries are multiline strings.
They're designed such that the querystring1 ++ querystring2 results in the common subset of both (or an error if the result matches no packets). 

#+name: q1
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  lk print-query example::/ok 
#+END_SRC
#+name: q2
#+BEGIN_SRC bash :session codeorg :exports both :results output verbatim
  lk print-query example::/ok -- "spacename:=:/not_ok"
#+END_SRC

That's it for this quick introduction.
For a more in-depth technical guide or the library API see the [[./guide/index.html][Guide]].
The show some of this in action. 
